(* Odd-even transposition sort in singleton SILL *)
(* Henry DeYoung *)
(* January 10, 2015 *)

stype Elem = +{ someR: &{ someL: int => int ∧ Elem , noneL: Elem } ,
                noneR: Elem ,
                done: int list ∧ 1 }

(* oesort : int list -> { |- int list ∧ 1 } *)
oesort xs = { loadR xs 0; hdL }

(* loadR : int list -> nat -> { |- Elem } *)
  loadR [] N = { tlR N }
| loadR (x::xs) N =
    { loadL xs (s N); elemR x }

(* loadL : int list -> nat -> { |- Elem } *)
  loadL [] N = { tlR N }
| loadL (x::xs) N =
    { loadR xs (s N); elemL x }

(* elemR : int -> { Elem |- Elem *)
elemR y =
  { selectR someR;
    caseR of
      someL => x ← recvR;
               sendR y;
               if x > y then elemL x
               else elemL y
    | noneL => elemL y }

(* elemL : int -> { Elem |- Elem } *)
elemL x =
  { caseL of
      someR => selectL someL;
               sendL x;
               y ← recvL;
               if x > y then elemR y
               else elemR x
    | noneR => elemR x
    | done => L ← recvL; waitL;
              selectR done;
              sendR (x::L); closeR }

(* hdL : { Elem |- int list ∧ 1 } *)
hdL =
  { caseL of 
      someR => selectL noneL;
               hdL
    | noneR => raise Impossible (* hdL *)
    | done => L ← recvL; waitL;
              sendR L; closeR }

(* tlR : nat -> { |- Elem } *)
  tlR 0 =
    { selectR done;
      sendR []; closeR }
| tlR (s N) =
    { selectR noneR; tlR N }



stype Elem 0 = int list ∧ 1
    | Elem (s N) = +{ someR: &{ someL: int => int ∧ Elem N , noneL: Elem N } ,
                      noneR: Elem N }

T3 R3 L3 R3 H3
T3 L2 R2 L2 H2

T4 L4 R4 ...
T3 R3 R4 ...

elemR : ΠN. int -> { Elem N |- Elem (s N) } 
elemL : ΠN. int -> { Elem (s N) |- Elem N }
elemL' : ΠN. int -> { Elem N |- Elem N }
elemR' : ΠN. int -> { Elem N |- Elem N }

(* elemL : ΠN. int -> { Elem (s N) |- Elem N } *)
  elemL (s N) x =
    { caseL of
        someR => selectL someL;
                 sendL x;
                 y ← recvL;
                 if x > y then elemR y
                 else elemR x
      | noneR => elemR x }
| elemL 0 x =
    { L ← recvL; waitL;
      sendR (x::L); closeR }

(* elemR : ΠN. int -> { Elem (s N) |- Elem (s N) } *)
elemR N y =
  { selectR someR;
    caseR of
      someL => x ← recvR;
               sendR y;
               if x > y then elemL x
               else elemL y
    | noneL => elemL y }

(* hdL : ΠN. { Elem N |- int list ∧ 1 } *)
  hdL (s N) =
    { caseL of 
        someR => selectL noneL;
                 hdL
      | noneR => raise Impossible (* hdL *) }
| hdL 0 =
    { L ← recvL; waitL;
      sendR L; closeR }

(* tlR : ΠN. { |- Elem N } *)
  tlR (s N) =
    { selectR noneR; tlR N }
| tlR 0 =
    { sendR []; closeR }



T2  L1  R2  H
T1  R1  L2  H
T1  L2  R1  H
T0  R2  L1  H
T0  L2  R1  H
D[2]  L1  H
D[1,2]  H



stype Elem 0 0 = int list ∧ 1
    | Elem (s N) 0 = +{ someR: Elem (s N) 0 , done: int list ∧ 1 }
    | Elem 0 (s M) = +{ noneR: Elem 0 (s M) , done: int list ∧ 1 }
    | Elem (s N) (s M) = +{ someR: int => int ∧ Elem (s N) (s M) , done: int list ∧ 1 }

(* elemL : ΠN.ΠM. int -> { Elem N (s M) |- Elem (s N) M } *)
  elemL 0 M x =
    { caseL of
        noneR => elemR 0 M x
      | done => L ← recvL; waitL;
                selectR done;
                sendR (x::L); closeR }
| elemL (s N') M x =
    { caseL of
        someR => sendL x;
                 y ← recvL;
                 if x > y then elemR (s N') M y
                 else elemR (s N') M x
      | done => L ← recvL; waitL;
                selectR done;
                sendR (x::L); closeR }

(* elemR : ΠN.ΠM. int -> { Elem N (s M) |- Elem (s N) M } *)
  elemR N 0 y =
    { selectR someR;
      elemL N 0 y }
| elemR N (s M') y =
    { selectR someR;
      x ← recvR;
      sendR y;
      if x > y then elemL N (s M') x
      else elemL N (s M') y

(* hdL : ΠN. { Elem N 0 |- int list ∧ 1 } *)
  hdL 0 =
    { L ← recvL; waitL;
      sendR L; closeR }
| hdL (s N') =
    { caseL of
        someR => hdL
      | done => L ← recvL; waitL;
                sendR L; closeR }

(* tlR : nat -> { |- Elem } *)
  tlR 0 =
    { selectR done;
      sendR []; closeR }
| tlR (s N) =
    { selectR noneR; tlR N }





T 3 4 1 2 H

H 2 1 4 3 T
H 1 2 3 4 T

H 4 3 2 1 T    3+3+3+3=12
H 4 2 3 1 T    3+2+2+3=10
H 2 4 1 3 T    1+2+2+1=6
H 2 1 4 3 T    1+1+1+1=4
H 1 2 3 4 T

H 3 4 2 1 T    2+2+3+3=10
H 3 2 4 1 T    2+2+


. 6 5 7 9 8 .
. 5 6 7 9 8 .
. 5 6 7 8 9



I(e) <= N-p after p steps

After 0 steps, I(e) <= N-1 < N-0.
Assume I(e) <= N-p after p steps.
WLOG assume I(e) = N-p.


αᵢ(p) ≤ N-p
βᵢ(p) ≤ N-p
Iᵢ(p) = αᵢ(p) + βᵢ(p) ≤ 2N-2p

A = 1 2 3 .. αᵢ(0) 0 0 0 .. 0
    1 2 3 4 0 0 0 0
    1 2 3 4 0 0 0 0   1 
    1 2 3 0 4 0 0 0   2
    1 2 0 3 0 4 0 0   3
    1 0 2 0 3 0 4 0   4
    0 1 0 2 0 3 0 4   5
    0 0 1 0 2 0 3 4   6
    0 0 0 1 0 2 3 4   7 
    0 0 0 0 1 2 3 4   8

αᵢ(0) ≤ N-1 < N-0


A = 1 1 1 1 0 0   0
    1 1 1 0 1 0   1
    1 1 0 1 0 1   2
    1 0 1 0 1 0   3
    0 1 0 1 1 1   4
    0 0 1 1 1 1   5

lᵢ⁺(p) = αᵢ(0) - p       if p=0 or αᵢ(0) is even
       = αᵢ(0) - p + 1   if p>0 and αᵢ(0) is odd

lᵢ⁺(0) = αᵢ(0) = αᵢ(0) - 0 

lᵢ⁺(p) = αᵢ(0) - p
Suppose p is even.



stype Elem p α = (α ≤ N-p) => +{ someR: &{ someL: int => int ∧ (α' ≤ N-(p+1)) ∧ Elem (p+1) α' , noneL: (α = 0) ∧ Elem (p+1) 0 } ,



..11000..
..10100..
..01010..

N-e+1
N-(e-1)+1 = N-e+2

..11100000..
..11010000..
..10101000..
..01010100..

..10100000..
..0101

N-(e-(i-1))+1
N-(e-i+1)+1
N-e+i



tw ← dutch ← tb , d , br =
{ case d of
    red => br' ← red ← br;
           tw ← dutch ← tb , d , br'
  | white => tw' ← dutch ← tb , d , br;
             tw ← white ← tw'
  | blue => 


45 38 12 62 42 34 8 24 76 48
^        L           R

45 38 12 24 42 34 8 62 76 48
^                   LR

8 38 12 24 42 34 45 62 76 48
  ^        L   R    ^  L   R

8 38 12 24 34 42 45 62 48 76
  ^         R L     ^   R L

8 34 12 24 38 42 45 48 62 76
  ^


45 38 12 62 42 34 8 24 76 48
45 38 12 24 42 34 8 62 76 48
8 38 12 24 42 34 45 62 76 48
8 38 12 24 42 34 45 62 48 76
8 38 12 24 42 34 45 48 62 76
8 38 12 24 34 42 45 48 62 76
8 24 12 34 38 42 45 48 62 76
8 12 24 34 38 42 45 48 62 76








































