% arara: pdflatex
% arara: pdflatex
% arara: biber
% arara: pdflatex
% arara: pdflatex
% \documentclass{../hdeyoung-proposal}
\documentclass[
  class=../hdeyoung-proposal,
  crop=false
]{standalone}


\usepackage{linear-logic}
\usepackage{ordered-logic}
\usepackage{proof}
\usepackage{mathpartir}

\usepackage{tikz}
% \usetikzlibrary{shapes.misc,graphs,graphdrawing}
% \usegdlibrary{trees}

\ExplSyntaxOn

% \DeclarePairedDelimiter \parens { \lparen } { \rparen }
\DeclarePairedDelimiter \bagged:wn { \lbag } { \rbag }
\NewDocumentCommand{ \bagged }{ s o m o }
  {
    \IfBooleanTF {#1}
      { \bagged:wn* {#3} }
      {
        \IfValueTF {#2}
          { \bagged:wn[#2] {#3} }
          { \bagged:wn {#3} }
      }
    \IfValueT {#4} { \sb{#4} }
  }


\NewDocumentCommand \oseq { >{ \SplitArgument{1}{|-} } m }
  { \oseq:nn #1 }
\cs_new:Npn \oseq:nn #1#2 { \oseq_ctxs:n {#1} \vdash #2 }
\cs_new:Npn \oseq_ctxs:n #1 {
  \seq_set_split:Nnn \l_tmpa_seq {;} {#1}
  \seq_use:Nn \l_tmpa_seq { \mathrel{;} }
}

\NewDocumentCommand \procof { m m } { #1 \dblcolon #2 }
\NewDocumentCommand \hypof { m } { #1 }


\NewDocumentCommand \cut { m } { \text{\textsc{\MakeLowercase{Cut}}}\sb{#1} }
\NewDocumentCommand \id { m } { \text{\textsc{\MakeLowercase{Id}}}\sb{#1} }

\NewDocumentCommand \comp { >{ \SplitArgument{1}{|} } m }
  { \comp:nn #1 }
\cs_new:Npn \comp:nn #1#2 { #1 \parallel #2 }

\NewDocumentCommand \fwd {} { \mathord{\leftrightarrow} }


\RenewDocumentCommand \with { s }
  { \IfBooleanTF {#1} \with:n \with: }
\cs_new:Npn \with:n #1 {
  \mathord{\binampersand}
  \bagged {
    \seq_set_split:Nnn \l_tmpa_seq {,} {#1}
    \seq_use:Nn \l_tmpa_seq {,}
  }
}
\cs_new:Npn \with: { \mathbin{\binampersand} }

\NewDocumentCommand \ssor { s }
  { \IfBooleanTF {#1} \with:n \with: }
\cs_new:Npn \ssor:n #1 {
  \mathord{\ssor:}
  \bagged {
    \seq_set_split:Nnn \l_tmpa_seq {,} {#1}
    \seq_use:Nn \l_tmpa_seq {,}
  }
}
\cs_new:Npn \ssor: { \oplus }

\NewDocumentCommand \caseR { s m }
  {
    \IfBooleanTF {#1}
      { \case:nNn { \mathsf{caseR} } \bagged {#2} }
      { \case:nNn { \mathsf{caseR} } \parens {#2} }
  }
\NewDocumentCommand \caseL { s m }
  {
    \IfBooleanTF {#1}
      { \case:nNn { \mathsf{caseL} } \bagged {#2} }
      { \case:nNn { \mathsf{caseL} } \parens {#2} }
  }
\cs_new:Npn \case:nNn #1#2#3 {
  #1 \mskip\thinmuskip
  #2 {
    \seq_set_split:Nnn \l_tmpa_seq {|} {#3}
    \seq_clear:N \l_tmpb_seq
    \seq_map_inline:Nn \l_tmpa_seq
      { \seq_put_right:Nn \l_tmpb_seq { \case_branch:n {##1} } }
    \seq_use:Nn \l_tmpb_seq { \mid }
  }
}
\cs_new:Npn \case_branch:n #1 { \case_branch_aux:w #1 \q_stop }
\cs_new:Npn \case_branch_aux:w #1 => #2 \q_stop {
  #1 \Rightarrow #2
}

\NewDocumentCommand \selectL { >{ \SplitArgument{1}{;} } m }
  { \select:nnn { \mathsf{selectL} } #1 }
\NewDocumentCommand \selectR { >{ \SplitArgument{1}{;} } m }
  { \select:nnn { \mathsf{selectR} } #1 }
\cs_new:Npn \select:nnn #1#2#3 {
  \!\mathord{}\mathop{#1} #2 ; #3
}


\NewDocumentCommand \inj { m } { \mathsf{in}\sb{#1} }

\NewDocumentCommand \inl {} { \inj{ \mathsf{1} } }
\NewDocumentCommand \inr {} { \inj{ \mathsf{2} } }


\RenewDocumentCommand \one {} { \mathord { \mathbf{1} } }

\NewDocumentCommand \quitR {} { \mathsf{quitR} }
\NewDocumentCommand \waitL { m } { \mathsf{waitL} ; #1 }


\NewDocumentCommand \rrule { o m } {
  \IfValueTF {#1}
    { \rrule:nn {#2} {#1} }
    { \rrule:n {#2} }
}
\cs_new:Npn \rrule:nn #1#2 { {#1}\text{\textsc{\MakeLowercase{R}}}\sb{#2} }
\cs_new:Npn \rrule:n #1 { {#1}\text{\textsc{\MakeLowercase{R}}} }

\NewDocumentCommand \lrule { o m } {
  \IfValueTF {#1}
    { \lrule:nn {#2} {#1} }
    { \lrule:n {#2} }
}
\cs_new:Npn \lrule:nn #1#2 { {#1}\text{\textsc{\MakeLowercase{L}}}\sb{#2} }
\cs_new:Npn \lrule:n #1 { {#1}\text{\textsc{\MakeLowercase{L}}} }


\NewDocumentCommand \exec { } { \mathsf{exec} \mskip\thinmuskip }
\NewDocumentCommand \msg { } { \mathsf{msg} \mskip\thinmuskip }

\ExplSyntaxOff



\DeclareAcronym{SSOS}{
  short = SSOS,
  long = substructural operational semantics,
  short-format = \scshape\MakeLowercase
}
\DeclareAcronym{SILL}{
  short = \MakeLowercase{SILL},
  long = session-typed intuitionistic linear logic,
  short-format = \scshape
}

\addbibresource{../proposal.bib}

\NewDocumentCommand{\ie}{}{i.e.}


\usepackage{listings}

\NewDocumentCommand{\msill}{}{
  \lstinline[basicstyle=\ttfamily,basewidth=0.5em]`
}
\NewDocumentCommand{\pctx}{}{\Psi}
\ExplSyntaxOn
\NewDocumentCommand{\ctxmonad}{>{\SplitArgument{1}{<-}}m}{
  \{\use_ii:nn #1 \vdash \use_i:nn #1\}
}
\NewDocumentCommand{\spawn}{>{\SplitArgument{1}{;}}m}{
  \mathsf{spawn}\mskip\thinmuskip\use_i:nn#1 ; \use_ii:nn#1
}
\NewDocumentCommand{\mbind}{>{\SplitArgument{1}{;}}m}{
  \use_i:nn#1 ; \use_ii:nn#1
}
\NewDocumentCommand{\mletrec}{m m}{
  \mathsf{letrec} \mskip\thinmuskip #1 \mskip\thinmuskip \mathsf{in} \mskip\thinmuskip #2
}
\NewDocumentCommand{\mprocdef}{m}{
  #1
}
\ExplSyntaxOff


\NewDocumentEnvironment{sillcode}{O{}}{\begin{lstlisting}[#1]}{\end{lstlisting}}

\begin{document}

\section{}

In a session-based model of concurrency, pairs of processes interact in well-defined sessions, with one process offering a service that its session partner uses.
Session types, pioneered by \textcite{Honda:CONCUR93}, describe the interaction protocol to which a process adheres when offering its service the processes in that session must adhere.
When processes interact, the session type changes: one process now offers, and the other uses, the continuation of the initial service.
The logical reading of session-based concurrency is linear logic exactly because it can express this change of state.

Because a process offers its service along a distinguished channel, \ac{SILL}'s basic session-typing judgment is $P :: c{:}A$, meaning \enquote{process $P$ offers service of type $A$ along channel $c$}.
However, $P$ itself may rely on services offered by yet other processes, and so, more generally, \ac{SILL}'s session-typing judgment is a linear sequent annotated as
\begin{equation*}
  \underbrace{
    c_0{:}A_0 , c_1{:}A_1 , \dots , c_n{:}A_n
  }_{\textstyle \lctx}
  \vdash
  P :: c{:}A
\end{equation*}
% where the channel names, $x_i$, are needed to unambiguously refer to hypotheses and the consequent.
meaning \enquote{Using services $A_i$ offered along channels $c_i$, the process $P$ offers service $A$ along channel $c$.}
(The channels $c_i$ and $c$ must all be distinct and are binding occurrences with scope over the process $P$.)

With this session-typing judgment, the inference rules of the linear sequent calculus become \ac{SILL} session-typing rules for concurrent processes.
For instance, the cut rule of \ac{SILL} types a parallel composition of processes (shown in $\pi$-calculus syntax here):
\begin{equation*}
  \infer[\cut{A}]{\lctx , \lctx' \vdash (\nu x)(P \mid Q) :: z{:}C}{
    \lctx \vdash P :: x{:}A &
    \lctx' , x{:}A \vdash Q :: z{:}C}
\end{equation*}
Top-level $\cut{}$s thus arrange processes in a tree-shaped network, such as the following, in which some processes are clients of more than one process (i.e., some nodes have more than one child).
\begin{equation*}
  % \begin{tikzpicture}
  %   \graph [
  %     tree layout, grow=left, math nodes, % empty nodes,
  %     nodes={
  %       rounded rectangle, rounded rectangle left arc=none,
  %       draw, minimum size=2ex,
  %     }
  %   ] {
  %     / [draw=none] <-
  %     Q <- { "P_1" <- / <- { / , / } ,
  %            / ,
  %            / <- { / , / <- / } };
  %   };
  % \end{tikzpicture}
\end{equation*}
Each edge in the above \ac{SILL} tree represents a top-level $\cut{}$, and each top-level $\cut{}$ corresponds to a hypothesis that serves as its principal formula.
% Each hypothesis gives rise to a top-level $\cut{}$, represented as an edge in the above graph. 

In this note, we are interested in developing a restriction of \ac{SILL} in which the process networks are linearly ordered:
\begin{center}
  % \begin{tikzpicture}
  %   \graph [tree layout, grow=left, empty nodes, nodes={draw, circle}] {
  %     / [draw=none] <-
  %     x <- y <- z <- w;
  %   };
  % \end{tikzpicture}
\end{center}

Therefore, for the process network to be linearly ordered, contexts $\lctx$ must be either singletons or empty.
In this special case, sequents have one of the simpler forms
\begin{equation*}
  x_0{:}A_0 \vdash P :: x_1{:}A_1
  \quad\text{or}\quad
  \lctxe \vdash P :: x_1{:}A_1
  \,.
\end{equation*}


% exec(spawn P; Q) -> {exec P * exec Q}

\subsection{Additive conjunction as branching}\label{sec:addit-conj-as-branch}

So far we have discussed only a judgmental principle that applies to all services; specifc services are defined by the right and left rules of the logical connectives.
When restricted to singleton or empty anticidents, the linear sequent calculus rules for the additive conjunction $A_1 \with A_2$ are as follows.
Note that in this case the left rules' contexts are forced to be the singleton $A_1 \with A_2$.
\begin{mathpar}
  \infer[\rrule{\with}]{\oseq{\lctx |- A_1 \with A_2}}{
    \oseq{\lctx |- A_1} &
    \oseq{\lctx |- A_2}}
  \and
  \infer[{\lrule[1]{\with}}]{\oseq{A_1 \with A_2 |- C}}{
    \oseq{A_1 |- C}}
  \and
  \infer[{\lrule[2]{\with}}]{\oseq{A_1 \with A_2 |- C}}{
    \oseq{A_2 |- C}}
\end{mathpar}

The right rule, $\rrule{\with}$, says that to prove $A_1 \with A_2$ we must prove both $A_1$ and $A_2$ (using the same resources $\lctx$) so that we are prepared for whichever of the two resources, $A_1$ or $A_2$, is eventually chosen by a $\lrule[1]{\with}$ or $\lrule[2]{\with}$ left rule.
Correspondingly, a process that offers service $A_1 \with A_2$ gives its client a choice of services $A_1$ and $A_2$; the process must be prepared to offer whichever service the client chooses.
Based on this intuition, we interpret the $\rrule{\with}$ rule as typing a binary guarded choice:
\begin{equation*}
  \infer[\rrule{\with}]{\oseq{\lctx |- \procof{\caseR{\inl => P_1 | \inr => P_2}}{A_1 \with A_2}}}{
    \oseq{\lctx |- \procof{P_1}{A_1}} &
    \oseq{\lctx |- \procof{P_2}{A_2}}}
\end{equation*}
where $\caseR{\inl => P_1 | \inr => P_2}$ means \enquote{Input either $\inl$ or $\inr$ along the right-hand channel, and then continue as process $P_1$ or $P_2$, respectively.}

Conversely, the client sitting to the right that uses service $A_1 \with A_2$ must behave in a complementary way: the client should select either service $A_1$ or service $A_2$ and then, having notifed the offering process of its choice (as $\inl$ or $\inr$), continue the session by using that service.
The left rules for type $A_1 \with A_2$ are thus:
\begin{mathpar}
  \infer[{\lrule[1]{\with}}]{\oseq{\hypof{A_1 \with A_2} |- \procof{\selectL{\inl; Q}}{C}}}{
    \oseq{\hypof{A_1} |- \procof{Q}{C}}}
  \and
  \infer[{\lrule[2]{\with}}]{\oseq{\hypof{A_1 \with A_2} |- \procof{\selectL{\inr; Q}}{C}}}{
    \oseq{\hypof{A_2} |- \procof{Q}{C}}}
\end{mathpar}
where $\selectL{\inj{\mathsf{1/2}} ; Q}$ means \enquote{Send label $\inj{\mathsf{1/2}}$ along the left-hand channel and then continue as process $Q$.}

Our intuition about the behavior of the guarded choice processes is made precise by their operational semantics.
First, the $\inl$ branch:
\begin{equation*}
  \begin{lgathered}
    \exec(\selectL{\inl ; Q}) \lrimp \monad{\msg{\inl} \fuse \exec{Q}} \\
    \exec(\caseR{\inl => P_1 | \inr => P_2}) \fuse \msg{\inl} \lrimp \monad{\exec{P_1}}
      \,.
  \end{lgathered}
\end{equation*}
To execute the selection process $\selectL{\inl ; Q}$, we asynchronously send to the left a message containing the label $\inl$, which is represented in the \ac{SSOS} as the proposition $\msg{\inl}$, and then immediately continue the session by executing $Q$, \ie\ process $Q$.
When this message arrives, the destination process $\caseR{\inl => P_1 | \inr => P_2}$ resumes execution as $P_1$.

The operational semantics of the $\inr$ branch is symmetric to that of the $\inl$ branch:
\begin{equation*}
  \begin{lgathered}
    \exec(\selectL{\inr ; Q}) \lrimp \monad{\msg{\inr} \fuse \exec{Q}} \\
    \exec(\caseR{\inl => P_1 | \inr => P_2}) \fuse \msg{\inr} \lrimp \monad{\exec{P_2}}
      \,.
  \end{lgathered}
\end{equation*}

\paragraph{Practical considerations.}

% To make the language more palatable for the programmer, we diverge slightly from a pure propositions-as-types interpretation of one-dimensional linear logic by including $n$-ary labeled additive conjunctions $\with*{\ell_i: A_i}[i \in I]$ as a primitive.
% Formaly, the conjunction is over a mutiset of label-type pairs,
% % expressed as a parametric comprehension
% indexed by set $I$
% \autocite{Cervesato+Sans:FI14}

To make the language more palatable for the programmer, we diverge slightly from a pure propositions-as-types interpretation of one-dimensional linear logic by including $n$-ary labeled additive conjunctions as a primitive.
Formally, these types $\with*{\ell_i: A_i}[i \in I]$ are conjunctions over multiset comprehensions~\autocite{Cervesato+Sans:FI14} of label--type pairs.

By analogy with the binary conjunction, the static and operational semantics of $\with*{\ell_i: A_i}[i \in I]$ are as follows.
\begin{gather*}
  \infer[\rrule{\with}]{\oseq{\lctx |- \procof{\caseR*{\ell_i => P_i}[i \in I]}{\with*{\ell_i: A_i}[i \in I]}}}{
    \bagged{\oseq{\lctx |- \procof{P_i}{A_i}}}[i \in I]}
  \\
  \bagged{
    \infer[{\lrule[k]{\with}}]{\oseq{\hypof{\with*{\ell_i: A_i}[i \in I]} |- \procof{\selectL{\ell_k; Q}}{C}}}{
      \oseq{\hypof{A_k} |- \procof{Q}{C}}}
  }[k \in I]
  \\[2\jot]
  \begin{lgathered}
    \bagged{
      \exec(\selectL{\ell_k ; Q}) \lrimp \monad{\msg{\ell_k} \fuse \exec{Q}}
    }[k \in I] \\
    \bagged{
      \exec(\caseR*{\ell_i => P_i}[i \in I]) \fuse \msg{\ell_k} \lrimp \monad{\exec{P_k}}
    }[k \in I]
      \,.
  \end{lgathered}
\end{gather*}
According to the multiset nature of the type, our presentation uses the multiset-oriented inference rules of \textcite{Cervesato+Sans:FI14}: the $\rrule{\with}$ right rule has a multiset of premises---one for each index $i \in I$---and there is a multiset of $\lrule[k]{\with}$ left rules.

Another possibility would be to simply treat $n$-ary labeled conjunctions as syntactic sugar for nested binary conjunctions, but this would turn out to introduce a communication overhead because we would be sending multiple $\inj{\mathsf{1/2}}$s separately rather than a single label $\ell_k$.


\subsubsection{Recursive session types and process definitions}\label{sec:recurs-sess-types}

Concurrent processes frequently exhibit unbounded or infinite, yet well-defined, behavior;
for instance, we may wish to have a counter that offers an increment service indefinitely.
To this end, \textcite{Toninho+:coind13} are currently extending their \ac{SILL} type theory with inductive and coinductive session types.
Meanwhile, however, we must content ourselves to depart from a pure Curry-Howard correspondence and instead rely on general recursion.

Session types thus include general recursive types, $\mu t.A$, and type variables, $t$.
The type $\mu t.A$ is interpreted equi-recursively, being identified with its unfolding, namely $\subst{(\mu t.A)/t}{A}$.
Processes correspondingly include mutually recursive process definitions, via \msill`letrec`, and process variables, $X$.

We extend the session-typing judgment with a context, $\pctx$, of process variable typings.
% Because a process is typed according to the services that it uses and offers, process variables are typed as $X : \ctxmonad{A <- \vec{B}}$, meaning that process $X$ can offer service $A$ if provided with channels along which services $\vec{B}$ are offered.
Because a process is typed according with a sequent of services that it uses and offers, process variables are typed as ${X : \ctxmonad{A <- \lctx}}$ if process $X$ can offer service $A$ 
% when provided with channels along which services $\vec{B}$ are offered.
by using services $\lctx$.
When channels of appropriate types are available, the process $X$ can be called:
\begin{equation*}
  \infer[\text{\scshape call}]{\oseq{\pctx, X{:}\ctxmonad{A <- \lctx} ; \lctx |- \procof{X}{A}}}{
    }
  \:.
\end{equation*}
A common idiom is $\spawn{X ; Q}$, which spawns a call to $X$ that is run in parallel with some process $Q$.
We will frequently abbreviate this with the syntactic sugar $\mbind{X ; Q}$.

% Mutually recursive process definitions add process variables to the context.
% Process variables are added to the context to allow for mutual recursion.
In mutually recursive process definitions,
% , the programmer declares each process with a type that must be checked.
the process bodies may refer to any of the mutually recursive processes via process variables.
The typing rule is
\begin{equation*}
  \infer[\text{\scshape letrec}]{\oseq{\pctx ; \lctx |- \procof{\mletrec{\bagged{\mprocdef{X_i = P_i}}[i \in I]}{Q}}{C}}}{
    \bagged{
      \oseq{\pctx, \bagged{X_i{:}\ctxmonad{A_i <- \lctx_i}}[i \in I] ; \lctx_j |- \procof{P_j}{A_j}}
    }[j \in I]
    &
    \oseq{\pctx, \bagged{X_i{:}\ctxmonad{A_i <- \lctx_i}}[i \in I] ; \lctx |- \procof{Q}{C}}}
  \,.
\end{equation*}

Now, having presented recursion, we can finally give a simple example program.


\subsection{Example: Binary counter}\label{sec:exampl-binary-count}

We can implement a simple session-typed counter on natural numbers as shown in \cref{fig:counter-inc}.%
\footnote{This example is adapted from one by \textcite{Toninho+:ESOP13}.}
%
\begin{lstlisting}[
  basicstyle=\ttfamily,basewidth=0.5em,
  caption={A simple binary counter supporting an increment operation},%
  label={fig:counter-inc},%
  gobble=2
]
  stype Counter = &{ inc: Counter }
  
  eps : {|- Counter}
  eps =
  { caseR of
      inc => eps; bit1 }
  
  bit0 : {Counter |- Counter}
  bit0 =
  { caseR of
      inc => bit1 }
  
  bit1 : {Counter |- Counter}
  bit1 =
  { caseR of
      inc => selectL inc;
             bit0 }
\end{lstlisting}
%
The counter is a chain of \lstinline[basicstyle=\ttfamily,basewidth=0.5em]`bit0` and \lstinline[basicstyle=\ttfamily,basewidth=0.5em]`bit1` processes, one for each bit in the binary representation of the counter's value, and is terminated at the most significant end with an \lstinline[basicstyle=\ttfamily,basewidth=0.5em]`eps` process.
For instance, the process chain \lstinline[basicstyle=\ttfamily,basewidth=0.5em]`eps -> bit1 -> bit0 ->` represents a counter with value $2$.

The counter offers a very simple service: the client may only choose to increment the counter, with the same service being offered recursively after the increment.
This service, \lstinline[basicstyle=\ttfamily,basewidth=0.5em]`Counter`, is therefore a recursive additive conjunction, declared in the concrete syntax as \lstinline[basicstyle=\ttfamily,basewidth=0.5em]`stype Counter = &{ inc: Counter }`.
The \lstinline[basicstyle=\ttfamily,basewidth=0.5em]`eps` process offers this service outright, and thus has type \lstinline[basicstyle=\ttfamily,basewidth=0.5em]`{|- Counter}`.
The \lstinline[basicstyle=\ttfamily,basewidth=0.5em]`bit0` and \lstinline[basicstyle=\ttfamily,basewidth=0.5em]`bit1` processes, on the other hand, use the service offered by their more significant neighbors, and thus have type \lstinline[basicstyle=\ttfamily,basewidth=0.5em]`{Counter |- Counter}`.

The process definitions of \lstinline[basicstyle=\ttfamily,basewidth=0.5em]`eps`, \lstinline[basicstyle=\ttfamily,basewidth=0.5em]`bit0`, and \lstinline[basicstyle=\ttfamily,basewidth=0.5em]`bit1` are mutually recursive.
When an \lstinline[basicstyle=\ttfamily,basewidth=0.5em]`eps` process receives an \lstinline[basicstyle=\ttfamily,basewidth=0.5em]`inc` message, it creates a new most significant bit by spawning a new \lstinline[basicstyle=\ttfamily,basewidth=0.5em]`eps` process and then making a recursive call to a \lstinline[basicstyle=\ttfamily,basewidth=0.5em]`bit1` process.
% that uses the service offered by the new \lstinline[basicstyle=\ttfamily,basewidth=0.5em]`eps`.
When a \lstinline[basicstyle=\ttfamily,basewidth=0.5em]`bit0` process receives an \lstinline[basicstyle=\ttfamily,basewidth=0.5em]`inc`, the bit is flipped by virtue of a recursive call to a \lstinline[basicstyle=\ttfamily,basewidth=0.5em]`bit1` process.
Lastly, when a \lstinline[basicstyle=\ttfamily,basewidth=0.5em]`bit1` process receives an \lstinline[basicstyle=\ttfamily,basewidth=0.5em]`inc`, the bit is flipped and a carry is propagated; this is accomplished by first sending \lstinline[basicstyle=\ttfamily,basewidth=0.5em]`inc` along channel \lstinline[basicstyle=\ttfamily,basewidth=0.5em]`d` to the \lstinline[basicstyle=\ttfamily,basewidth=0.5em]`Counter` offered by the next more significant bit and then making a recursive call to a \lstinline[basicstyle=\ttfamily,basewidth=0.5em]`bit0` process.

Informally, we can see that, as implemented, the \lstinline[basicstyle=\ttfamily,basewidth=0.5em]`inc` operation respects a counter's denotation: whenever a counter representing natural number $n$ is incremented, the resulting counter represents $n+1$.
Note, however, that this adequacy property is not enforced by the type \lstinline[basicstyle=\ttfamily,basewidth=0.5em]`Counter`.
An appropriate dependent session type could enforce increment adequacy, but, for simplicity of presentation, we prefer the simple type for now.

\end{document}
