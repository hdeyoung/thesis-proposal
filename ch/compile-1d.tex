% arara: pdflatex
% arara: pdflatex
% arara: biber
% arara: pdflatex
% arara: pdflatex
% \documentclass{../hdeyoung-proposal}
\documentclass[
  class=../hdeyoung-proposal,
  crop=false
]{standalone}


\usepackage{linear-logic}
\usepackage{ordered-logic}
\usepackage{basic-atoms}
\usepackage{proof}
\usepackage{mathpartir}

\usepackage{tikz}
% \usetikzlibrary{shapes.misc,graphs,graphdrawing}
% \usegdlibrary{trees}

\ExplSyntaxOn

% \DeclarePairedDelimiter \parens { \lparen } { \rparen }
\DeclarePairedDelimiter \bagged:wn { \lbag } { \rbag }
\NewDocumentCommand{ \bagged }{ s o m o }
  {
    \IfBooleanTF {#1}
      { \bagged:wn* {#3} }
      {
        \IfValueTF {#2}
          { \bagged:wn[#2] {#3} }
          { \bagged:wn {#3} }
      }
    \IfValueT {#4} { \sb{#4} }
  }


\NewDocumentCommand \oseq { >{ \SplitArgument{1}{|-} } m }
  { \oseq:nn #1 }
\cs_new:Npn \oseq:nn #1#2 { \oseq_ctxs:n {#1} \vdash #2 }
\cs_new:Npn \oseq_ctxs:n #1 {
  \seq_set_split:Nnn \l_tmpa_seq {;} {#1}
  \seq_use:Nn \l_tmpa_seq { \mathrel{;} }
}

\NewDocumentCommand \procof { m m } { #1 \dblcolon #2 }
\NewDocumentCommand \hypof { m } { #1 }


\NewDocumentCommand \cut { m } { \text{\textsc{\MakeLowercase{Cut}}}\sb{#1} }
\NewDocumentCommand \id { m } { \text{\textsc{\MakeLowercase{Id}}}\sb{#1} }

\NewDocumentCommand \comp { >{ \SplitArgument{1}{|} } m }
  { \comp:nn #1 }
\cs_new:Npn \comp:nn #1#2 { #1 \parallel #2 }

\NewDocumentCommand \fwd {} { \mathord{\leftrightarrow} }


\RenewDocumentCommand \with { s }
  { \IfBooleanTF {#1} \with:n \with: }
\cs_new:Npn \with:n #1 {
  \mathord{\binampersand}
  \bagged {
    \seq_set_split:Nnn \l_tmpa_seq {,} {#1}
    \seq_use:Nn \l_tmpa_seq {,}
  }
}
\cs_new:Npn \with: { \mathbin{\binampersand} }

\NewDocumentCommand \ssor { s }
  { \IfBooleanTF {#1} \with:n \with: }
\cs_new:Npn \ssor:n #1 {
  \mathord{\ssor:}
  \bagged {
    \seq_set_split:Nnn \l_tmpa_seq {,} {#1}
    \seq_use:Nn \l_tmpa_seq {,}
  }
}
\cs_new:Npn \ssor: { \oplus }

\NewDocumentCommand \caseR { s m }
  {
    \IfBooleanTF {#1}
      { \case:nNn { \mathsf{caseR} } \bagged {#2} }
      { \case:nNn { \mathsf{caseR} } \parens {#2} }
  }
\NewDocumentCommand \caseL { s m }
  {
    \IfBooleanTF {#1}
      { \case:nNn { \mathsf{caseL} } \bagged {#2} }
      { \case:nNn { \mathsf{caseL} } \parens {#2} }
  }
\cs_new:Npn \case:nNn #1#2#3 {
  #1 \mskip\thinmuskip
  #2 {
    \seq_set_split:Nnn \l_tmpa_seq {|} {#3}
    \seq_clear:N \l_tmpb_seq
    \seq_map_inline:Nn \l_tmpa_seq
      { \seq_put_right:Nn \l_tmpb_seq { \case_branch:n {##1} } }
    \seq_use:Nn \l_tmpb_seq { \mid }
  }
}
\cs_new:Npn \case_branch:n #1 { \case_branch_aux:w #1 \q_stop }
\cs_new:Npn \case_branch_aux:w #1 => #2 \q_stop {
  #1 \Rightarrow #2
}

\NewDocumentCommand \selectL { >{ \SplitArgument{1}{;} } m }
  { \select:nnn { \mathsf{selectL} } #1 }
\NewDocumentCommand \selectR { >{ \SplitArgument{1}{;} } m }
  { \select:nnn { \mathsf{selectR} } #1 }
\cs_new:Npn \select:nnn #1#2#3 {
  \!\mathord{}\mathop{#1} #2 ; #3
}


\NewDocumentCommand \inj { m } { \mathsf{in}\sb{#1} }

\NewDocumentCommand \inl {} { \inj{ \mathsf{1} } }
\NewDocumentCommand \inr {} { \inj{ \mathsf{2} } }


\RenewDocumentCommand \one {} { \mathord { \mathbf{1} } }

\NewDocumentCommand \quitR {} { \mathsf{quitR} }
\NewDocumentCommand \waitL { m } { \mathsf{waitL} ; #1 }


\NewDocumentCommand \rrule { o m } {
  \IfValueTF {#1}
    { \rrule:nn {#2} {#1} }
    { \rrule:n {#2} }
}
\cs_new:Npn \rrule:nn #1#2 { {#1}\text{\textsc{\MakeLowercase{R}}}\sb{#2} }
\cs_new:Npn \rrule:n #1 { {#1}\text{\textsc{\MakeLowercase{R}}} }

\NewDocumentCommand \lrule { o m } {
  \IfValueTF {#1}
    { \lrule:nn {#2} {#1} }
    { \lrule:n {#2} }
}
\cs_new:Npn \lrule:nn #1#2 { {#1}\text{\textsc{\MakeLowercase{L}}}\sb{#2} }
\cs_new:Npn \lrule:n #1 { {#1}\text{\textsc{\MakeLowercase{L}}} }


\NewDocumentCommand \exec { } { \mathsf{exec} \mskip\thinmuskip }
\NewDocumentCommand \msg { } { \mathsf{msg} \mskip\thinmuskip }

\ExplSyntaxOff


\DeclareAcronym{SSOS}{
  short = SSOS,
  long = substructural operational semantics,
  short-format = \scshape\MakeLowercase
}
\DeclareAcronym{SILL}{
  short = \MakeLowercase{SILL},
  long = session-typed intuitionistic linear logic,
  short-format = \scshape
}

\addbibresource{../proposal.bib}


\ExplSyntaxOn

\NewDocumentCommand \spawn { >{ \SplitArgument{1}{;} }m } { \spawn:nn #1 }
\cs_new:Npn \spawn:nn #1#2 { \mathsf{spawn} \mskip\thinmuskip #1 ; #2 }

\NewDocumentCommand \call { m } { \call:n {#1} }
\cs_new:Npn \call:n #1 { \mathsf{call} \mskip\thinmuskip #1 }

\NewDocumentCommand \cmp { m m } { \compile:nn {#1} {#2} }
\cs_new:Npn \compile:nn #1#2 { \llbracket #1 \rrbracket = #2 }

\NewDocumentCommand \trans { o } {
  \IfValueTF {#1}
    { \trans:n {#1} }
    { \trans: }
}
\cs_new:Npn \trans: { \longrightarrow }
\cs_new:Npn \trans:n #1 { \overset {#1} { \trans: } }

\ExplSyntaxOff


\begin{document}

\section{}

\begin{mathpar}
  \infer{\cmp{A^+ \fuse \matom[->]}{\selectR{\matom[->] ; P}}}{
    \cmp{A^+}{P}}
  \and
  \infer{\cmp{\matom[<-] \fuse A^+}{\selectL{\matom[<-] ; P}}}{
    \cmp{A^+}{P}}
  \and
  \infer{\cmp{\patom}{\call{\patom}}}{
    }
  \\
  \infer{\cmp{A^+_1 \fuse A^+_2}{\spawn{P_1 ; P_2}}}{
    \cmp{A^+_1}{P_1} &
    \cmp{A^+_2}{P_2}}
  \and
  \infer{\cmp{\one}{\fwd}}{
    }
\end{mathpar}

\begin{mathpar}
  \infer{\cmp{\monad{A^+}}{P}}{
    \cmp{A^+}{P}}
  \and
  \infer{\cmp{\with*{\matom[->]_i \limp \monad{A^+_i}}[i \in I]}{\caseL*{\matom[->]_i => P_i}[i \in I]}}{
    \bagged{\cmp{A^+_i}{P_i}}[i \in I]}
  \and
  \infer{\cmp{\with*{\matom[<-]_i \rimp \monad{A^+_i}}[i \in I]}{\caseR*{\matom[<-]_i => P_i}[i \in I]}}{
    \bagged{\cmp{A^+_i}{P_i}}[i \in I]}
\end{mathpar}

\begin{mathpar}
  \infer{\cmp{\matom[->]}{\msg{\matom[->]}}}{
    }
  \and
  \infer{\cmp{\matom[<-]}{\msg{\matom[<-]}}}{
    }
  \and
  \infer{\cmp{\patom}{\exec{P}}}{
    \patom \lrimp A^- \in \sig &
    \cmp{A^-}{P}}
  \\
  \infer{\cmp{A^+}{\exec{P}}}{
    \cmp{A^+}{P}}
  \and
  \infer{\cmp{A^-}{\exec{P}}}{
    \cmp{A^-}{P}}
  \and
  \infer{\cmp{\octx_1, \octx_2}{\lctx_1, \lctx_2}}{
    \cmp{\octx_1}{\lctx_1} &
    \cmp{\octx_2}{\lctx_2}}
  \and
  \infer{\cmp{\octxe}{\octxe}}{
    }
\end{mathpar}

\begin{theorem}[Completeness]\mbox{}
  \begin{itemize}
  \item If $\octx \trans \octx'$ and $\cmp{\octx}{\lctx}$, then $\lctx \trans \lctx'$ for some $\lctx'$ such that $\cmp{\octx'}{\lctx'}$.
  \item If $\octx \fboxsep=0pt\fbox{$\trans[\smash{\raisebox{-0.5ex}{$\scriptstyle\tau$}}]}^? \trans^? \octx'$ and $\cmp{\octx}{\lctx}$, then $\cmp{\octx'}{\lctx}$ also.
  \end{itemize}
\end{theorem}

\begin{theorem}[Soundness]\mbox{}
  \begin{itemize}
  \item If $\lctx \trans \lctx'$ and $\cmp{\octx}{\lctx}$, then $\octx \trans \octx'$ for some $\octx'$ such that $\cmp{\octx'}{\lctx'}$.
  \item If $\lctx, \exec{(\call{\patom})} \trans \lctx, \exec{P}$ and $\cmp{\octx}{\lctx}$, then $\patom \lrimp A^- \in \sig$ for some $A^-$ such that $\cmp{A^-}{P}$.
  \end{itemize}
\end{theorem}

\end{document}
