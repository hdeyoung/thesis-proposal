% arara: lualatex
% arara: lualatex
% arara: biber
% arara: lualatex
% arara: lualatex
% \documentclass{../hdeyoung-proposal}
\documentclass[
  class=../hdeyoung-proposal,
  crop=false
]{standalone}


\usepackage{linear-logic}
\usepackage{ordered-logic}
\usepackage{proof}
\usepackage{mathpartir}

\usepackage{tikz}
\usetikzlibrary{shapes.misc,graphs,quotes,graphdrawing}
\usegdlibrary{trees}

\usepackage{scalerel}

\ExplSyntaxOn

% \DeclarePairedDelimiter \parens { \lparen } { \rparen }
\DeclarePairedDelimiter \bagged:wn { \lbag } { \rbag }
\NewDocumentCommand{ \bagged }{ s o m o }
  {
    \IfBooleanTF {#1}
      { \bagged:wn* {#3} }
      {
        \IfValueTF {#2}
          { \bagged:wn[#2] {#3} }
          { \bagged:wn {#3} }
      }
    \IfValueT {#4} { \sb{#4} }
  }


\NewDocumentCommand \oseq { >{ \SplitArgument{1}{|-} } m }
  { \oseq:nn #1 }
\cs_new:Npn \oseq:nn #1#2 { \oseq_ctxs:n {#1} \vdash #2 }
\cs_new:Npn \oseq_ctxs:n #1 {
  \seq_set_split:Nnn \l_tmpa_seq {;} {#1}
  \seq_use:Nn \l_tmpa_seq { \mathrel{;} }
}

\NewDocumentCommand \procof { m m } { #1 \dblcolon #2 }
\NewDocumentCommand \hypof { m } { #1 }


\NewDocumentCommand \cut { m } { \text{\textsc{\MakeLowercase{Cut}}}\sb{#1} }
\NewDocumentCommand \id { m } { \text{\textsc{\MakeLowercase{Id}}}\sb{#1} }

\NewDocumentCommand \comp { >{ \SplitArgument{1}{|} } m }
  { \comp:nn #1 }
\cs_new:Npn \comp:nn #1#2 { #1 \parallel #2 }

\NewDocumentCommand \fwd {} { \mathord{\leftrightarrow} }


\RenewDocumentCommand \with { s }
  { \IfBooleanTF {#1} \with:n \with: }
\cs_new:Npn \with:n #1 {
  \mathord{\binampersand}
  \bagged {
    \seq_set_split:Nnn \l_tmpa_seq {,} {#1}
    \seq_use:Nn \l_tmpa_seq {,}
  }
}
\cs_new:Npn \with: { \mathbin{\binampersand} }

\NewDocumentCommand \ssor { s }
  { \IfBooleanTF {#1} \ssor:n \ssor: }
\cs_new:Npn \ssor:n #1 {
  \mathord{\ssor:}
  \bagged {
    \seq_set_split:Nnn \l_tmpa_seq {,} {#1}
    \seq_use:Nn \l_tmpa_seq {,}
  }
}
\cs_new:Npn \ssor: { \oplus }

\NewDocumentCommand \caseR { s m }
  {
    \IfBooleanTF {#1}
      { \case:nNn { \mathsf{caseR} } \bagged {#2} }
      { \case:nNn { \mathsf{caseR} } \parens {#2} }
  }
\NewDocumentCommand \caseL { s m }
  {
    \IfBooleanTF {#1}
      { \case:nNn { \mathsf{caseL} } \bagged {#2} }
      { \case:nNn { \mathsf{caseL} } \parens {#2} }
  }
\cs_new:Npn \case:nNn #1#2#3 {
  #1 \mskip\thinmuskip
  #2 {
    \seq_set_split:Nnn \l_tmpa_seq {|} {#3}
    \seq_clear:N \l_tmpb_seq
    \seq_map_inline:Nn \l_tmpa_seq
      { \seq_put_right:Nn \l_tmpb_seq { \case_branch:n {##1} } }
    \seq_use:Nn \l_tmpb_seq { \talloblong }
  }
}
\cs_new:Npn \case_branch:n #1 { \case_branch_aux:w #1 \q_stop }
\cs_new:Npn \case_branch_aux:w #1 => #2 \q_stop {
  #1 \Rightarrow #2
}

\NewDocumentCommand \selectL { >{ \SplitArgument{1}{;} } m }
  { \select:nnn { \mathsf{selectL} } #1 }
\NewDocumentCommand \selectR { >{ \SplitArgument{1}{;} } m }
  { \select:nnn { \mathsf{selectR} } #1 }
\cs_new:Npn \select:nnn #1#2#3 {
  \!\mathord{}\mathop{#1} #2 ; #3
}


\NewDocumentCommand \inj { m } { \mathsf{in}\sb{#1} }

\NewDocumentCommand \inl {} { \inj{ \mathsf{1} } }
\NewDocumentCommand \inr {} { \inj{ \mathsf{2} } }


\RenewDocumentCommand \one {} { \mathord { \mathbf{1} } }

\NewDocumentCommand \quitR {} { \mathsf{quitR} }
\NewDocumentCommand \waitL { m } { \mathsf{waitL} ; #1 }


\NewDocumentCommand \rrule { o m } {
  \IfValueTF {#1}
    { \rrule:nn {#2} {#1} }
    { \rrule:n {#2} }
}
\cs_new:Npn \rrule:nn #1#2 { {#1}\text{\textsc{\MakeLowercase{R}}}\sb{#2} }
\cs_new:Npn \rrule:n #1 { {#1}\text{\textsc{\MakeLowercase{R}}} }

\NewDocumentCommand \lrule { o m } {
  \IfValueTF {#1}
    { \lrule:nn {#2} {#1} }
    { \lrule:n {#2} }
}
\cs_new:Npn \lrule:nn #1#2 { {#1}\text{\textsc{\MakeLowercase{L}}}\sb{#2} }
\cs_new:Npn \lrule:n #1 { {#1}\text{\textsc{\MakeLowercase{L}}} }


\NewDocumentCommand \exec { } { \mathsf{exec} \mskip\thinmuskip }
\NewDocumentCommand \msg { } { \mathsf{msg} \mskip\thinmuskip }

\ExplSyntaxOff




\addbibresource{../proposal.bib}

\NewDocumentCommand{\ie}{}{i.e.}


\usepackage{listings}
\crefname{listing}{listing}{listings}
\Crefname{listing}{Listing}{Listings}

\newlength{\mywidth}
\settowidth{\mywidth}{\ttfamily A}
\lstset{basicstyle=\ttfamily, basewidth=\mywidth}

\captionsetup[lstlisting]{%
  box=colorbox, boxcolor=gray,
  font={normalfont, sf, color=white},
  labelfont=bf,
  justification=justified, singlelinecheck=false
}

\lstnewenvironment{sillcode}[1][]
  {\lstset{language={},frame=bottomline,framerule=0.8ex,rulecolor=\color{gray},float,#1}}%
  {}

\lstnewenvironment{sillcode*}[1][]
  {\lstset{language={},#1}}%
  {}

\NewDocumentCommand{\sillinline}{o}{%
  \IfValueTF{#1}{\lstinline[#1]}{\lstinline}%
}


\NewDocumentCommand{\pctx}{}{\Psi}
\ExplSyntaxOn
\NewDocumentCommand{\ctxmonad}{>{\SplitArgument{1}{<-}}m}{
  \{\use_ii:nn #1 \vdash \use_i:nn #1\}
}
\NewDocumentCommand \spawn { >{ \SplitArgument{1}{;} } m } { \spawn:nn #1 }
\cs_new:Npn \spawn:nn #1#2 {
  \mathsf{spawn}
  \tl_if_empty:nF {#1} {
    \mskip\thinmuskip #1 ; #2
  }
}
\NewDocumentCommand{\mbind}{>{\SplitArgument{1}{;}}m}{
  \use_i:nn#1 ; \use_ii:nn#1
}
\NewDocumentCommand{\mletrec}{m m}{
  \mathsf{letrec} \mskip\thinmuskip #1 \mskip\thinmuskip \mathsf{in} \mskip\thinmuskip #2
}
\NewDocumentCommand{\mprocdef}{m}{
  #1
}
\ExplSyntaxOff




\input{acronyms.tex}


\begin{document}

\section{Proposed work}\label{sec:proposed-work}

In this document, we have shown how session types form a bridge between a class of ordered logical specifications and process definitions typed in singleton linear logic---between proof-construction-as-computation and proof-reduction-as-computation.
The primary area of proposed work is to extend this connection to (a class of) linear logical specifications and \ac{SILL} process definitions typed in linear logic.
% To defend the proposed thesis, this connection must be extended to (a class of) linear logical specifications and \ac{SILL} process definitions typed in linear logic.

\subsection{From ordered logical specifications to linear logical specifications}\label{sec:from-ordered-logical}

Although awkward, it is possible to give an ordered logical specification for addition of two binary numbers.
The idea is to arrange the numbers end-to-end, but separated by a $\plus$ marker and terminated by a $\equals$ marker.
For instance, the string
\begin{equation*}
  \eps \fuse \bit{1} \fuse \bit{0} \fuse \plus \fuse \bit{1} \fuse \bit{0} \fuse \equals
\end{equation*}
would represent a request to add $2+2$.
By decrementing the second number to $0$ and incrementing

\begin{equation*}
  \begin{lgathered}
    \bit{0} \fuse \dec \lrimp \monad{\dec \fuse \bit[']{0}} \\
    \bit{1} \fuse \dec \lrimp \monad{\skip \fuse \bit{0} \fuse \ok} \\
    \plus \fuse \dec \lrimp \monad{\fail} \\
    %
    \bit{0} \fuse \skip \lrimp \monad{\skip \fuse \bit{0}} \\
    \bit{1} \fuse \skip \lrimp \monad{\skip \fuse \bit{1}} \\
    \plus \fuse \skip \lrimp \monad{\inc \fuse \plus} \\
    %
    \ok \fuse \bit[']{0} \lrimp \monad{\bit{1} \fuse \ok} \\
    \fail \fuse \bit[']{0} \lrimp \monad{\fail} \\
    %
    \ok \fuse \equals['] \lrimp \monad{\equals} \\
    \fail \fuse \equals['] \lrimp \monad{\one}
  \end{lgathered}
\end{equation*}


\begin{sillcode}
  plus =
  { caseR of
      dec => selectR fail; <->
    | skip_inc => selectL inc; plus }

  bit0 =
  { caseR of
      dec => selectL dec; bit0'
    | skip_inc => selectL skip_inc; bit0 }

  bit0' =
  { caseL of
      ok => selectR ok; bit1
    | fail => selectR fail; <-> }

  bit1 =
  { caseR of
      dec => selectR ok; selectL skip_inc; bit0
    | skip_inc => selectL skip_inc; bit1 }

  equals =
  { selectL dec; equals' }

  equals' =
  { caseL of
      ok => equals
    | fail => <-> }
\end{sillcode}


A better algorithm would add the two numbers bit-by-bit.
Pictorially, 
\begin{equation*}
  \begin{tikzpicture}
    \graph [tree layout, math nodes] {
      + <- { / 0 <- / 1 <- / e ,
/ 0 <- / 1 <- / e };
};
  \end{tikzpicture}
\end{equation*}

\end{document}