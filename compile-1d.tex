% arara: pdflatex
% arara: pdflatex
% arara: biber
% arara: pdflatex
% arara: pdflatex
% \documentclass{../hdeyoung-proposal}
\documentclass[
  class=../hdeyoung-proposal,
  crop=false
]{standalone}


\usepackage{linear-logic}
\usepackage{ordered-logic}
\usepackage{basic-atoms}
\usepackage{proof}
\usepackage{mathpartir}

\usepackage{tikz}
% \usetikzlibrary{shapes.misc,graphs,graphdrawing}
% \usegdlibrary{trees}

\ExplSyntaxOn

% \DeclarePairedDelimiter \parens { \lparen } { \rparen }
\DeclarePairedDelimiter \bagged:wn { \lbag } { \rbag }
\NewDocumentCommand{ \bagged }{ s o m o }
  {
    \IfBooleanTF {#1}
      { \bagged:wn* {#3} }
      {
        \IfValueTF {#2}
          { \bagged:wn[#2] {#3} }
          { \bagged:wn {#3} }
      }
    \IfValueT {#4} { \sb{#4} }
  }


\NewDocumentCommand \oseq { >{ \SplitArgument{1}{|-} } m }
  { \oseq:nn #1 }
\cs_new:Npn \oseq:nn #1#2 { \oseq_ctxs:n {#1} \vdash #2 }
\cs_new:Npn \oseq_ctxs:n #1 {
  \seq_set_split:Nnn \l_tmpa_seq {;} {#1}
  \seq_use:Nn \l_tmpa_seq { \mathrel{;} }
}

\NewDocumentCommand \procof { m m } { #1 \dblcolon #2 }
\NewDocumentCommand \hypof { m } { #1 }


\NewDocumentCommand \cut { m } { \text{\textsc{\MakeLowercase{Cut}}}\sb{#1} }
\NewDocumentCommand \id { m } { \text{\textsc{\MakeLowercase{Id}}}\sb{#1} }

\NewDocumentCommand \comp { >{ \SplitArgument{1}{|} } m }
  { \comp:nn #1 }
\cs_new:Npn \comp:nn #1#2 { #1 \parallel #2 }

\NewDocumentCommand \fwd {} { \mathord{\leftrightarrow} }


\RenewDocumentCommand \with { s }
  { \IfBooleanTF {#1} \with:n \with: }
\cs_new:Npn \with:n #1 {
  \mathord{\binampersand}
  \bagged {
    \seq_set_split:Nnn \l_tmpa_seq {,} {#1}
    \seq_use:Nn \l_tmpa_seq {,}
  }
}
\cs_new:Npn \with: { \mathbin{\binampersand} }

\NewDocumentCommand \ssor { s }
  { \IfBooleanTF {#1} \ssor:n \ssor: }
\cs_new:Npn \ssor:n #1 {
  \mathord{\ssor:}
  \bagged {
    \seq_set_split:Nnn \l_tmpa_seq {,} {#1}
    \seq_use:Nn \l_tmpa_seq {,}
  }
}
\cs_new:Npn \ssor: { \oplus }

\NewDocumentCommand \caseR { s m }
  {
    \IfBooleanTF {#1}
      { \case:nNn { \mathsf{caseR} } \bagged {#2} }
      { \case:nNn { \mathsf{caseR} } \parens {#2} }
  }
\NewDocumentCommand \caseL { s m }
  {
    \IfBooleanTF {#1}
      { \case:nNn { \mathsf{caseL} } \bagged {#2} }
      { \case:nNn { \mathsf{caseL} } \parens {#2} }
  }
\cs_new:Npn \case:nNn #1#2#3 {
  #1 \mskip\thinmuskip
  #2 {
    \seq_set_split:Nnn \l_tmpa_seq {|} {#3}
    \seq_clear:N \l_tmpb_seq
    \seq_map_inline:Nn \l_tmpa_seq
      { \seq_put_right:Nn \l_tmpb_seq { \case_branch:n {##1} } }
    \seq_use:Nn \l_tmpb_seq { \mid }
  }
}
\cs_new:Npn \case_branch:n #1 { \case_branch_aux:w #1 \q_stop }
\cs_new:Npn \case_branch_aux:w #1 => #2 \q_stop {
  #1 \Rightarrow #2
}

\NewDocumentCommand \selectL { >{ \SplitArgument{1}{;} } m }
  { \select:nnn { \mathsf{selectL} } #1 }
\NewDocumentCommand \selectR { >{ \SplitArgument{1}{;} } m }
  { \select:nnn { \mathsf{selectR} } #1 }
\cs_new:Npn \select:nnn #1#2#3 {
  \!\mathord{}\mathop{#1} #2 ; #3
}


\NewDocumentCommand \inj { m } { \mathsf{in}\sb{#1} }

\NewDocumentCommand \inl {} { \inj{ \mathsf{1} } }
\NewDocumentCommand \inr {} { \inj{ \mathsf{2} } }


\RenewDocumentCommand \one {} { \mathord { \mathbf{1} } }

\NewDocumentCommand \quitR {} { \mathsf{quitR} }
\NewDocumentCommand \waitL { m } { \mathsf{waitL} ; #1 }


\NewDocumentCommand \rrule { o m } {
  \IfValueTF {#1}
    { \rrule:nn {#2} {#1} }
    { \rrule:n {#2} }
}
\cs_new:Npn \rrule:nn #1#2 { {#1}\text{\textsc{\MakeLowercase{R}}}\sb{#2} }
\cs_new:Npn \rrule:n #1 { {#1}\text{\textsc{\MakeLowercase{R}}} }

\NewDocumentCommand \lrule { o m } {
  \IfValueTF {#1}
    { \lrule:nn {#2} {#1} }
    { \lrule:n {#2} }
}
\cs_new:Npn \lrule:nn #1#2 { {#1}\text{\textsc{\MakeLowercase{L}}}\sb{#2} }
\cs_new:Npn \lrule:n #1 { {#1}\text{\textsc{\MakeLowercase{L}}} }


\NewDocumentCommand \exec { } { \mathsf{exec} \mskip\thinmuskip }
\NewDocumentCommand \msgR { } { \mathsf{msgR} \mskip\thinmuskip }
\NewDocumentCommand \msgL { } { \mathsf{msgL} \mskip\thinmuskip }

\ExplSyntaxOff


\input{acronyms.tex}

\addbibresource{../proposal.bib}


\ExplSyntaxOn

\NewDocumentCommand \spawn { >{ \SplitArgument{1}{;} }m } { \spawn:nn #1 }
\cs_new:Npn \spawn:nn #1#2 { \mathsf{spawn} \mskip\thinmuskip #1 ; #2 }

\NewDocumentCommand \call { m } { \call:n {#1} }
\cs_new:Npn \call:n #1 { \mathsf{call} \mskip\thinmuskip #1 }

\NewDocumentCommand \cmp { m g } {
  \IfValueTF {#2}
    { \compile:nn {#1} {= #2} }
    { \compile:nn {#1} {} }
}
\cs_new:Npn \compile:nn #1#2 { \llbracket #1 \rrbracket #2 }

\NewDocumentCommand \trans { o } {
  \IfValueTF {#1}
    { \trans:n {#1} }
    { \trans: }
}
\cs_new:Npn \trans: { \longrightarrow }
\cs_new:Npn \trans:n #1 {
  \mathrel {
    \smash { \overset { \raisebox {-1ex} { $\scriptstyle #1$ } } { \trans: } }
    \vphantom { \trans: }
  }
}
\NewDocumentCommand \strans { } { \trans[\tau] }

\NewDocumentCommand \sig { } { \Sigma }

\NewDocumentCommand \chseq { } { \vdash^{\mathrm{ch}} }

\ExplSyntaxOff


\begin{document}

\section{}

The goal of this document is to relate the two notions of concurrency that arise in ordered logical specifications and session-typed process chains, respectively.
The proposed thesis is to then establish a more general relationship between \emph{linear} logical specifications and session-typed process \emph{trees}.
Thus far, we have reviewed propositional ordered logical specifications (\cref{?}), identified a class of message-passing choreographies (\cref{?}), and presented a well-defined restriction of linear logic that serves as a session-typing discipline for process chains (\cref{?}).
We are finally ready to tackle this document's main result.

First, we show how to translate choreographies to process chains.

\subsection{Translation of choreographies to process chains}

Recall the grammar of \emph{local} propositions given in \cref{?}:
% Recall the refined grammar of propositions given in \cref{?} for choreographies:
% \begin{alignat*}{3}
%   &\text{Negative propositions} &\quad&& A^-,B^- &::= A^- \with B^- \mid \monad{A^+} \mid \matom[<-]^+ \rimp \monad{A^+} \mid \matom[->]^+ \limp \monad{A^+} \\
%   &\text{Positive propositions}      &&& A^+,B^+ &::= A^+ \fuse B^+ \mid \one \mid \matom[<-]^+ \fuse A^+ \mid A^+ \fuse \matom[->]^+ \mid \p^+ \mid A^-
% \end{alignat*}
% Because our focus in this document is on \emph{well-typed} process chains, we'll need to make one more refinement to the grammar.
% 
% Consider $(\matom[->]^+_1 \limp \monad{A^+_1}) \with (\matom[<-]^+_2 \rimp \monad{A^+_2})$.
% Intuitively, this negative proposition should correspond to an input-guarded nondeterministic choice: the process should choose to either receive $\matom[->]^+_1$ from the left and continue as process $A^+_1$, or receive $\matom[<-]^+_2$ from the right and continue as process $A^+_2$.
% However, as a nondeterministic choice that waits to receive from either side, such a process is not typable.
% We rule out these propositions by ensuring that the arms of an additive conjunction are consistently left- or right-implications:
\begin{alignat*}{3}
  &\text{Negative propositions} &\quad&& A^-,B^- &::= \monad{A^+} \mid \with*{\matom[<-]^+_i \rimp \monad{A^+_i}}[i \in I] \mid \with*{\matom[->]^+_i \limp \monad{A^+_i}}[i \in I] \\
  &\text{Positive propositions}      &&& A^+,B^+ &::= A^+ \fuse B^+ \mid \one \mid \matom[<-]^+ \fuse A^+ \mid A^+ \fuse \matom[->]^+ \mid \p^+ \mid A^-
\end{alignat*}



The translation from choreographies to process chains is syntax-directed, according to the proposition's polarity.
The principle that guides the design of this translation is that transitions from a context $\octx$ should be matched by transitions of the process network to which $\octx$ translates.

\paragraph{Translating negative propositions.}
The rules for translating negative propositions are:
\begin{mathpar}
  \infer{\cmp{\monad{A^+}}{P}}{
    \cmp{A^+}{P}}
  \and
  \infer{\cmp{\with*{\matom[<-]_i \rimp \monad{A^+_i}}[i \in I]}{\caseR*{\matom[<-]_i => P_i}[i \in I]}}{
    \forall i \in I\mathpunct{:}\enskip  \cmp{A^+_i}{P_i}}
  \and
  \infer{\cmp{\with*{\matom[->]_i \limp \monad{A^+_i}}[i \in I]}{\caseL*{\matom[->]_i => P_i}[i \in I]}}{
    \forall i \in I\mathpunct{:}\enskip  \cmp{A^+_i}{P_i}}
\end{mathpar}
The lax modality $\monad{A^+}$ translates just as $A^+$ does: the modality is silent.
The proposition $\with*{\matom[<-]_i \rimp \monad{A^+_i}}[i \in I]$ is a $\mathsf{caseR}$ process that waits to receive one of the labels $\matom[<-]_i$ from the right side; the arms of the case are exactly the translations of each $A^+_i$.
Likewise, $\with*{\matom[->]_i \limp \monad{A^+_i}}[i \in I]$ is a $\mathsf{caseL}$ process.

Intuitively, this translation is the correct one because the $\mathsf{caseR}$ receives a message $\matom[<-]_k$ and continues as $P_k$ exactly when the proposition $\with*{\matom[<-]_i \rimp \monad{A^+_i}}[i \in I]$ transitions to $A^+_k$.
A similar intuition applies to the $\mathsf{caseL}$ process.


\paragraph{Translating positive propositions.}
Positive propositions, which appear only in monadic heads in this grammar, are also translated to processes.
\begin{mathpar}
  \infer{\cmp{\matom[<-] \fuse A^+}{\selectL{\matom[<-] ; P}}}{
    \cmp{A^+}{P}}
  \and
  \infer{\cmp{A^+ \fuse \matom[->]}{\selectR{\matom[->] ; P}}}{
    \cmp{A^+}{P}}
  \and
  \infer{\cmp{\patom}{\call{\patom}}}{
    }
  \\
  \infer{\cmp{A^+_1 \fuse A^+_2}{\spawn{P_1 ; P_2}}}{
    \cmp{A^+_1}{P_1} &
    \cmp{A^+_2}{P_2}}
  \and
  \infer{\cmp{\one}{\fwd}}{
    }
\end{mathpar}
The message conjunctions $\matom[<-] \fuse A^+$ and $A^+ \fuse \matom[->]$ translate to left and right selection processes $\selectL{\matom[<-] ; P}$ and $\selectR{\matom[->] ; P}$, respectively, where the continuation process $P$ is obtained by translating $A^+$.
Process-like atoms translate to calls to the corresponding process variable.
A general ordered conjunction $A^+_1 \fuse A^+_2$ translates as the process composition of $P_1$ and $P_2$, the processes to which $A^+_1$ and $A^+_2$ translate.
Finally, $\one$ translates to a forwarding process.

The idea is that each inversion step is matched by an asynchronous transition from the process, such as the outermost inversion step for $\matom[<-] \fuse A^+$ being matched by the asynchronous decomposition of $\selectL{\matom[<-] ; P}$ into message $\matom[<-]$ and process $P$.


\paragraph{Translating contexts.}
Finally, ordered contexts, $\octx$, translate to chains of executing processes, which are represented as ordered contexts in the \ac{SSOS}.
The translation proceeds homomorphically over contexts, with each hypothesis becoming \iac{SSOS} hypothesis in the translation.
\begin{mathpar}
  \infer{\cmp{\octx_1, \octx_2}{\lctx_1, \lctx_2}}{
    \cmp{\octx_1}{\lctx_1} &
    \cmp{\octx_2}{\lctx_2}}
  \and
  \infer{\cmp{\octxe}{\octxe}}{
    }
  \and
  \infer{\cmp{A^+}{\exec{P}}}{
    \cmp{A^+}{P}}
  \and
  \infer{\cmp{A^-}{\exec{P}}}{
    \cmp{A^-}{P}}
  \\
  \infer{\cmp{\matom[->]}{\msgR{\matom[->]}}}{
    }
  \and
  \infer{\cmp{\matom[<-]}{\msgL{\matom[<-]}}}{
    }
  \and
  \infer{\cmp{\patom}{\exec{P}}}{
    \patom \lrimp A^- \in \sig &
    \cmp{A^-}{P}}
\end{mathpar}
The left- and right-directed message-like atoms $\matom[<-]$ and $\matom[->]$ become the left- and right-directed messages $\msgL{\matom[<-]}$ and $\msgR{\matom[->]}$, respectively, in the \ac{SSOS}.
The process-like atom $\patom$ becomes $\exec{P}$, where $P$ is the process body of $\patom$'s definition.
Once again, the translation is defined in such a way that the behavior of contexts and their \ac{SSOS} translations match.

\subsection{Correctness of the translation}

As stressed in the preceding discussion, the principle that guided the translation's design was that the choreography's transitions should be matched by those of the process to which that choreography translates.
In other words, the translation, $\cmp{\cdot}$, should be a strong bisimulation.

Unfortunately, that property does not quite hold: $\cmp{\cdot}$ is not even a strong simulation.
Consider the choreography transition $\monad{A^+} \trans A^+$, for example.
For $\cmp{\cdot}$ to be a strong (bi-)simulation, there would have to be \iac{SSOS} transition $\exec{P} \trans \exec{P}$, where $\cmp{A^+}{P}$.
Such a transition simply does not exist in the \ac{SSOS} of our processes.

However, if we treat that transition (and those obtained from it by the frame property) as silent, then it is true that $\cmp{\cdot}$ is a \emph{weak simulation}: $\monad{A^+} \strans A^+$ and $\cmp{A^+}{P}$ indeed (trivially) imply $\exec{P} \strans* \exec{P}$.
More generally:
% , $\cmp{\cdot}$ is a weak simulation between the choreography and the process's \ac{SSOS}:
\begin{theorem}[Completeness]\mbox{}
  \begin{itemize}
  \item If $\octx \trans \octx'$ and $\cmp{\octx}{\lctx}$, then $\lctx \trans \lctx'$ for some $\lctx'$ such that $\cmp{\octx'}{\lctx'}$.
  \item If $\octx \trans[\tau] \octx'$ and $\cmp{\octx}{\lctx}$, then $\cmp{\octx'}{\lctx}$ also.
  \end{itemize}
\end{theorem}
\begin{proof}
  By analyzing the structure of the given transition and translation.
\end{proof}

Neither is the inverse of $\cmp{\cdot}$ a strong simulation.
Consider the \ac{SSOS} transition $\exec{(\call{\patom})} \trans \exec{P}$, where the body of process definition $\patom$ is $P$.
By examining the definition of $\cmp{\cdot}$, we see that there would have to be a choreography transition $\patom \trans \patom$ if the inverse of $\cmp{\cdot}$ is to be a strong simulation.
Once again, such a transition simply does not exist.

However, if we treat that transition (and those obtained from it by the frame property) as silent, then it is true that the inverse of $\cmp{\cdot}$ is a \emph{weak simulation}: $\exec{(\call{\patom})} \strans \exec{P}$ and $\cmp{\patom}{\exec{P}}$ indeed (trivially) imply $\patom \strans* \patom$.
More generally: 
\begin{theorem}[Soundness]\mbox{}
  \begin{itemize}
  \item If $\lctx \trans \lctx'$ and $\cmp{\octx}{\lctx}$, then $\octx \trans \octx'$ for some $\octx'$ such that $\cmp{\octx'}{\lctx'}$.
  \item If $\omatch{\exec{(\call{\patom})}} \trans \ofill{\exec{P}}$ and $\cmp{\omatch{{-}}}{\omatch[']{{-}}}$, then $\patom \lrimp A^- \in \sig$ for some $A^-$ such that $\cmp{A^-}{P}$.
  \end{itemize}
\end{theorem}
\begin{proof}
  By analyzing the structure of the given transition and translation.
\end{proof}

Putting these two pieces together, $\cmp{\cdot}$ is a weak bisimulation.


% As mentioned previously, guiding principle in the translation's design is that if the source specification $\octx$ translates to process chain $\lctx$, then each transition from $\octx$ should be matched by a transition from the process that results from translating the specification.
% As mentioned previously, guiding principle in the translation's design is that each transition from the source specification should be matched by a transition from the process that results from translating the specification.

% $\cmp{\cdot}{\cdot}$ is a weak bisimulation, when the transition $\omatch{\monad{A^+}} \trans \ofill{A^+}$ is a silent transition.  


% Just as the $\monad{-}$ modality is silent in the translation, we'll choose to classify the transition on ordered specifications from $\monad{A^+}$ to $A^+$ as silent: $\omatch{\monad{A^+}} \trans[\tau] \ofill{A^+}$.
% Then, the translation $\cmp{-}$ is a weak bisimulation: each transition is matched by a transition after translation, with the silent transitions disappearing.
% \begin{theorem}[Completeness]\mbox{}
%   \begin{itemize}
%   \item If $\octx \trans \octx'$ and $\cmp{\octx}{\lctx}$, then $\lctx \trans \lctx'$ for some $\lctx'$ such that $\cmp{\octx'}{\lctx'}$.
%   \item If $\octx \trans[\tau] \octx'$ and $\cmp{\octx}{\lctx}$, then $\cmp{\octx'}{\lctx}$ also.
%   \end{itemize}
% \end{theorem}
% \begin{proof}
%   By analyzing the definition of $\cmp{\octx}{\lctx}$. 
% \end{proof}

% \begin{theorem}[Soundness]\mbox{}
%   \begin{itemize}
%   \item If $\lctx \trans \lctx'$ and $\cmp{\octx}{\lctx}$, then $\octx \trans \octx'$ for some $\octx'$ such that $\cmp{\octx'}{\lctx'}$.
%   \item If $\lctx, \exec{(\call{\patom})} \trans \lctx, \exec{P}$ and $\cmp{\octx}{\lctx}$, then $\patom \lrimp A^- \in \sig$ for some $A^-$ such that $\cmp{A^-}{P}$.
%   \end{itemize}
% \end{theorem}


\subsection{}

At this point, we can translate choreographies to syntactically well-formed processes.
However, not all choreographies translate to \emph{well-typed} processes.
For example, $(A^+_1 \fuse \matom[->]_1) \fuse (\matom[<-]_2 \fuse A^+_2)$ translates to the process $\spawn{(\selectR{\matom[->]_1 ; P_1}); (\selectL{\matom[<-]_2 ; P_2})}$, which is not typable in \acs{SISLL} because the two messages, having no recipients, collide.

To identify a class of choreographies that enjoy the same session fidelity and, especially, progress properties as well-typed processes, we need to introduce a typing discipline for choreographies, $\chseq$, that is respected by the translation.
The following theorem is our goal:
%
\begin{theorem*}[Translation respects typing]\leavevmode
  \begin{itemize}
  \item If $\lctx \chseq A^- :: B$ and $\cmp{A^-}{P}$, then $\lctx \vdash P :: B$.
  \item If $\lctx \chseq A^+ :: B$ and $\cmp{A^+}{P}$, then $\lctx \vdash P :: B$.
  \end{itemize}
\end{theorem*}

Because $\cmp{\cdot}$ describes a fairly tight correspondence between choreographies and processes, the rules for $\chseq$ are \enquote{just} the rules for typing processes ($\vdash$): simply replace the process terms with the corresponding ordered logic proposition.
For instance, $\matom[<-]_k \fuse A^+$ translates to $\selectL{\matom[<-]_k ; P}$ and so, from the $\llab{\with}$ rule that types $\mathsf{selectL}$ processes, we obtain the rule for typing $\matom[<-]_k \fuse A^+$:
\begin{mathpar}
  \infer[\llab{\with}]{\oseq{\with*{\ell: A_\ell}[\ell \in L] |- \selectL{k ; P} :: C}}{
    \oseq{A_k |- P :: C}}
  %
  %
  \infer{\with*{\ell: A_\ell}[\ell \in L] \chseq \matom[<-]_k \fuse A^+ :: C}{
    A_k \chseq A^+ :: C}
\end{mathpar}

It's also possible to justify the rules for typing choreographies from first principles. 


\begin{mathpar}
  \infer{\lctx \chseq \with*{(\matom[<-]_\ell \rimp \monad{A^+_\ell})}[\ell \in L] :: \with*{\ell: A_\ell}[\ell \in L]}{
    \forall \ell \in L \mathpunct{:} \enskip \lctx \chseq A^+_\ell :: A_\ell}
  \and
  \infer{\with*{\ell: A_\ell} \chseq \matom[<-]_k \fuse A^+ :: C}{
    A_k \chseq A^+ :: C}
  \\
  \infer{\lctx \chseq A^+ \fuse \matom[->]_k :: \ssor*{\ell: A_\ell}}{
    \lctx \chseq A^+ :: A_k}
  \and
  \infer{\ssor*{\ell: A_\ell}[\ell \in L] \chseq \with*{(\matom[->]_\ell \limp \monad{A^+_\ell})}[\ell \in L] :: C}{
    \forall \ell \in L\mathpunct{:}\enskip A_\ell \chseq A^+_\ell :: C}
  \\
  \infer{\lctx \chseq \monad{A^+} :: A}{
    \lctx \chseq A^+ :: A}
  \and
  \infer{\lctx \chseq \patom :: A}{
    \patom \lrimp A^- \in \sig &
    \lctx \chseq A^- :: A}
  \\
  \infer{\lctx \chseq A^+_1 \fuse A^+_2 :: C}{
    \lctx \chseq A^+_1 :: A &
    A \chseq A^+_2 :: C}
  \and
  \infer{A \chseq \one :: A}{
    }
\end{mathpar}

\begin{theorem}[Typing]
  If $\lctx \chseq A^- :: B$ and $\cmp{A^-}{P}$, then $\lctx \vdash P :: B$.
\end{theorem}
\begin{proof}
  By induction on the structure of the typing derivation.
\end{proof}

\end{document}
