% % arara: pdflatex
% % arara: pdflatex
% % arara: biber
% % arara: pdflatex
% % arara: pdflatex
% % \documentclass{../hdeyoung-proposal}
% \documentclass[
%   class=../hdeyoung-proposal,
%   crop=false
% ]{standalone}


% \usepackage{linear-logic}
% \usepackage{ordered-logic}
% \usepackage{basic-atoms}
% \usepackage{proof}
% \usepackage{mathpartir}

% \usepackage{tikz}
% % \usetikzlibrary{shapes.misc,graphs,graphdrawing}
% % \usegdlibrary{trees}

% \ExplSyntaxOn

% % \DeclarePairedDelimiter \parens { \lparen } { \rparen }
% \DeclarePairedDelimiter \bagged:wn { \lbag } { \rbag }
% \NewDocumentCommand{ \bagged }{ s o m o }
%   {
%     \IfBooleanTF {#1}
%       { \bagged:wn* {#3} }
%       {
%         \IfValueTF {#2}
%           { \bagged:wn[#2] {#3} }
%           { \bagged:wn {#3} }
%       }
%     \IfValueT {#4} { \sb{#4} }
%   }


% \NewDocumentCommand \oseq { >{ \SplitArgument{1}{|-} } m }
%   { \oseq:nn #1 }
% \cs_new:Npn \oseq:nn #1#2 { \oseq_ctxs:n {#1} \vdash #2 }
% \cs_new:Npn \oseq_ctxs:n #1 {
%   \seq_set_split:Nnn \l_tmpa_seq {;} {#1}
%   \seq_use:Nn \l_tmpa_seq { \mathrel{;} }
% }

% \NewDocumentCommand \procof { m m } { #1 \dblcolon #2 }
% \NewDocumentCommand \hypof { m } { #1 }


% \NewDocumentCommand \cut { m } { \text{\textsc{\MakeLowercase{Cut}}}\sb{#1} }
% \NewDocumentCommand \id { m } { \text{\textsc{\MakeLowercase{Id}}}\sb{#1} }

% \NewDocumentCommand \comp { >{ \SplitArgument{1}{|} } m }
%   { \comp:nn #1 }
% \cs_new:Npn \comp:nn #1#2 { #1 \parallel #2 }

% \NewDocumentCommand \fwd {} { \mathord{\leftrightarrow} }


% \RenewDocumentCommand \with { s }
%   { \IfBooleanTF {#1} \with:n \with: }
% \cs_new:Npn \with:n #1 {
%   \mathord{\binampersand}
%   \bagged {
%     \seq_set_split:Nnn \l_tmpa_seq {,} {#1}
%     \seq_use:Nn \l_tmpa_seq {,}
%   }
% }
% \cs_new:Npn \with: { \mathbin{\binampersand} }

% \NewDocumentCommand \ssor { s }
%   { \IfBooleanTF {#1} \ssor:n \ssor: }
% \cs_new:Npn \ssor:n #1 {
%   \mathord{\ssor:}
%   \bagged {
%     \seq_set_split:Nnn \l_tmpa_seq {,} {#1}
%     \seq_use:Nn \l_tmpa_seq {,}
%   }
% }
% \cs_new:Npn \ssor: { \oplus }

% \NewDocumentCommand \caseR { s m }
%   {
%     \IfBooleanTF {#1}
%       { \case:nNn { \mathsf{caseR} } \bagged {#2} }
%       { \case:nNn { \mathsf{caseR} } \parens {#2} }
%   }
% \NewDocumentCommand \caseL { s m }
%   {
%     \IfBooleanTF {#1}
%       { \case:nNn { \mathsf{caseL} } \bagged {#2} }
%       { \case:nNn { \mathsf{caseL} } \parens {#2} }
%   }
% \cs_new:Npn \case:nNn #1#2#3 {
%   #1 \mskip\thinmuskip
%   #2 {
%     \seq_set_split:Nnn \l_tmpa_seq {|} {#3}
%     \seq_clear:N \l_tmpb_seq
%     \seq_map_inline:Nn \l_tmpa_seq
%       { \seq_put_right:Nn \l_tmpb_seq { \case_branch:n {##1} } }
%     \seq_use:Nn \l_tmpb_seq { \mid }
%   }
% }
% \cs_new:Npn \case_branch:n #1 { \case_branch_aux:w #1 \q_stop }
% \cs_new:Npn \case_branch_aux:w #1 => #2 \q_stop {
%   #1 \Rightarrow #2
% }

% \NewDocumentCommand \selectL { >{ \SplitArgument{1}{;} } m }
%   { \select:nnn { \mathsf{selectL} } #1 }
% \NewDocumentCommand \selectR { >{ \SplitArgument{1}{;} } m }
%   { \select:nnn { \mathsf{selectR} } #1 }
% \cs_new:Npn \select:nnn #1#2#3 {
%   \!\mathord{}\mathop{#1} #2 ; #3
% }


% \NewDocumentCommand \inj { m } { \mathsf{in}\sb{#1} }

% \NewDocumentCommand \inl {} { \inj{ \mathsf{1} } }
% \NewDocumentCommand \inr {} { \inj{ \mathsf{2} } }


% \RenewDocumentCommand \one {} { \mathord { \mathbf{1} } }

% \NewDocumentCommand \quitR {} { \mathsf{quitR} }
% \NewDocumentCommand \waitL { m } { \mathsf{waitL} ; #1 }


% \NewDocumentCommand \rrule { o m } {
%   \IfValueTF {#1}
%     { \rrule:nn {#2} {#1} }
%     { \rrule:n {#2} }
% }
% \cs_new:Npn \rrule:nn #1#2 { {#1}\text{\textsc{\MakeLowercase{R}}}\sb{#2} }
% \cs_new:Npn \rrule:n #1 { {#1}\text{\textsc{\MakeLowercase{R}}} }

% \NewDocumentCommand \lrule { o m } {
%   \IfValueTF {#1}
%     { \lrule:nn {#2} {#1} }
%     { \lrule:n {#2} }
% }
% \cs_new:Npn \lrule:nn #1#2 { {#1}\text{\textsc{\MakeLowercase{L}}}\sb{#2} }
% \cs_new:Npn \lrule:n #1 { {#1}\text{\textsc{\MakeLowercase{L}}} }


% \NewDocumentCommand \exec { } { \mathsf{exec} \mskip\thinmuskip }
% \NewDocumentCommand \msgR { } { \mathsf{msgR} \mskip\thinmuskip }
% \NewDocumentCommand \msgL { } { \mathsf{msgL} \mskip\thinmuskip }

% \ExplSyntaxOff


% \input{acronyms.tex}

% \addbibresource{../proposal.bib}


% \ExplSyntaxOn

% \NewDocumentCommand \spawn { >{ \SplitArgument{1}{;} }m } { \spawn:nn #1 }
% \cs_new:Npn \spawn:nn #1#2 { \mathsf{spawn} \mskip\thinmuskip #1 ; #2 }

% \NewDocumentCommand \call { m } { \call:n {#1} }
% \cs_new:Npn \call:n #1 { \mathsf{call} \mskip\thinmuskip #1 }

% \NewDocumentCommand \cmp { m g } {
%   \IfValueTF {#2}
%     { \compile:nn {#1} {= #2} }
%     { \compile:nn {#1} {} }
% }
% \cs_new:Npn \compile:nn #1#2 { \llbracket #1 \rrbracket #2 }

% \NewDocumentCommand \trans { o } {
%   \IfValueTF {#1}
%     { \trans:n {#1} }
%     { \trans: }
% }
% \cs_new:Npn \trans: { \longrightarrow }
% \cs_new:Npn \trans:n #1 {
%   \mathrel {
%     \smash { \overset { \raisebox {-1ex} { $\scriptstyle #1$ } } { \trans: } }
%     \vphantom { \trans: }
%   }
% }
% \NewDocumentCommand \strans { } { \trans[\tau] }

% \NewDocumentCommand \sig { } { \Sigma }

% \NewDocumentCommand \chseq { } { \vdash^{\mathrm{ch}} }

% \ExplSyntaxOff


% \begin{document}

\section{From ordered logical specifications to processes}\label{sec:translation}

The goal of this document is to relate the two notions of concurrency that arise in ordered logical specifications and session-typed process chains, respectively.
% The proposed thesis is to then establish a more general relationship between \emph{linear} logical specifications and session-typed process \emph{trees}.
Thus far, we have reviewed propositional ordered logical specifications (\cref{sec:ordered-lp}), identified a class of message-passing choreographies (\cref{sec:choreographies}), and presented a well-defined restriction of linear logic that serves as a session-typing discipline for process chains (\cref{sec:sill}).
We are finally ready to tackle this document's main goal.

First, in \cref{sec:translation-desc}, we show how to translate choreographies to process chains.
\Cref{sec:compile-correct} demonstrates correctness of the translation, in the sense that the translation is a weak bisimulation.
Finally, in \cref{sec:chor-types}, we derive a typing discipline for choreographies and show that well-typed choreographies become well-typed processes under translation.

\subsection{Translation of choreographies to process chains}\label{sec:translation-desc}

Recall the grammar of \emph{local} propositions given in \cref{sec:locality}:
% Recall the refined grammar of propositions given in \cref{?} for choreographies:
% \begin{alignat*}{3}
%   &\text{Negative propositions} &\quad&& A^-,B^- &::= A^- \with B^- \mid \monad{A^+} \mid \matom[<-]^+ \rimp \monad{A^+} \mid \matom[->]^+ \limp \monad{A^+} \\
%   &\text{Positive propositions}      &&& A^+,B^+ &::= A^+ \fuse B^+ \mid \one \mid \matom[<-]^+ \fuse A^+ \mid A^+ \fuse \matom[->]^+ \mid \p^+ \mid A^-
% \end{alignat*}
% Because our focus in this document is on \emph{well-typed} process chains, we'll need to make one more refinement to the grammar.
% 
% Consider $(\matom[->]^+_1 \limp \monad{A^+_1}) \with (\matom[<-]^+_2 \rimp \monad{A^+_2})$.
% Intuitively, this negative proposition should correspond to an input-guarded nondeterministic choice: the process should choose to either receive $\matom[->]^+_1$ from the left and continue as process $A^+_1$, or receive $\matom[<-]^+_2$ from the right and continue as process $A^+_2$.
% However, as a nondeterministic choice that waits to receive from either side, such a process is not typable.
% We rule out these propositions by ensuring that the arms of an additive conjunction are consistently left- or right-implications:
\begin{alignat*}{3}
  &\text{Negative propositions} &\quad&& A^-,B^- &::= \monad{A^+} \mid \with*[i \in I][\parens]{\matom[<-]^+_i \rimp \monad{A^+_i}} \mid \with*[i \in I][\parens]{\matom[->]^+_i \limp \monad{A^+_i}} \\
  &\text{Positive propositions}      &&& A^+,B^+ &::= A^+ \fuse B^+ \mid \one \mid \matom[<-]^+ \fuse A^+ \mid A^+ \fuse \matom[->]^+ \mid \patom^+ \mid A^-
\end{alignat*}



The translation $\cmp{{-}}$ from choreographies to process chains is syntax-directed, according to the proposition's polarity.
The principle that guides the design of this translation is that each choreography transition from a context $\octx$ should be matched by a process-chain transition from the chain to which $\octx$ translates, and vice versa.

\paragraph{Translating negative propositions.}
The rules for translating negative propositions are:
\begin{mathpar}
  \infer{\cmp{\monad{A^+}}{P}}{
    \cmp{A^+}{P}}
  \and
  \infer{\cmp{\with*[i \in I][\parens]{\matom[<-]_i \rimp \monad{A^+_i}}}{\caseR[i \in I]{\matom[<-]_i => P_i}}}{
    \forall i \in I\mathpunct{:}\enskip  \cmp{A^+_i}{P_i}}
  \and
  \infer{\cmp{\with*[i \in I][\parens]{\matom[->]_i \limp \monad{A^+_i}}}{\caseL[i \in I]{\matom[->]_i => P_i}}}{
    \forall i \in I\mathpunct{:}\enskip  \cmp{A^+_i}{P_i}}
\end{mathpar}
The lax modality $\monad{A^+}$ translates just as $A^+$ does: the modality is silent.
The proposition $\with*[i \in I][\parens]{\matom[<-]_i \rimp \monad{A^+_i}}$ is a $\mathsf{caseR}$ process that waits to receive one of the labels $\matom[<-]_i$ from the right side; the arms of the case are exactly the translations of each $A^+_i$.
Likewise, $\with*[i \in I][\parens]{\matom[->]_i \limp \monad{A^+_i}}$ is a $\mathsf{caseL}$ process.

Intuitively, this translation is the correct one because the $\mathsf{caseR}$ receives a message $\matom[<-]_k$ and continues as $P_k$ exactly when the proposition $\with*[i \in I][\parens]{\matom[<-]_i \rimp \monad{A^+_i}}$ transitions to $A^+_k$.
A similar intuition applies to the $\mathsf{caseL}$ process.


\paragraph{Translating positive propositions.}
Positive propositions, which appear only in monadic heads in this grammar, are also translated to processes.
\begin{mathpar}
  \infer{\cmp{\matom[<-] \fuse A^+}{\selectL{\matom[<-] ; P}}}{
    \cmp{A^+}{P}}
  \and
  \infer{\cmp{A^+ \fuse \matom[->]}{\selectR{\matom[->] ; P}}}{
    \cmp{A^+}{P}}
  \and
  \infer{\cmp{\patom^+}{\call{\patom^+}}}{
    }
  \\
  \infer{\cmp{A^+_1 \fuse A^+_2}{\spawn{P_1 ; P_2}}}{
    \cmp{A^+_1}{P_1} &
    \cmp{A^+_2}{P_2}}
  \and
  \infer{\cmp{\one}{\fwd}}{
    }
\end{mathpar}
The message conjunctions $\matom[<-] \fuse A^+$ and $A^+ \fuse \matom[->]$ translate to left and right selection processes $\selectL{\matom[<-] ; P}$ and $\selectR{\matom[->] ; P}$, respectively, where the continuation process $P$ is obtained by translating $A^+$.
Process-like atoms translate to calls to the corresponding process variable.
A general ordered conjunction $A^+_1 \fuse A^+_2$ translates as the process composition of $P_1$ and $P_2$, the processes to which $A^+_1$ and $A^+_2$ translate.
Finally, $\one$ translates to a forwarding process.

The idea is that each inversion step is matched by an asynchronous transition from the process, such as the outermost inversion step for $\matom[<-] \fuse A^+$ into $\matom[<-] , A^+$ being matched by the asynchronous decomposition of $\selectL{\matom[<-] ; P}$ into message $\matom[<-]$ and executing process $P$.


\paragraph{Translating contexts.}
Finally, ordered contexts, $\octx$, translate to chains of executing processes, which are represented as ordered contexts in the \ac{SSOS}.
The translation proceeds homomorphically over contexts, with each hypothesis becoming \iac{SSOS} hypothesis in the translation.
\begin{mathpar}
  \infer{\cmp{\octx_1, \octx_2}{\lctx_1, \lctx_2}}{
    \cmp{\octx_1}{\lctx_1} &
    \cmp{\octx_2}{\lctx_2}}
  \and
  \infer{\cmp{\octxe}{\octxe}}{
    }
  \and
  \infer{\cmp{A^+}{\exec{P}}}{
    \cmp{A^+}{P}}
  \and
  \infer{\cmp{A^-}{\exec{P}}}{
    \cmp{A^-}{P}}
  \\
  \infer{\cmp{\matom[->]}{\msgR{\matom[->]}}}{
    }
  \and
  \infer{\cmp{\matom[<-]}{\msgL{\matom[<-]}}}{
    }
  \and
  \infer{\cmp{\patom^+}{\exec{P}}}{
    \patom^+ \lrimp A^- \in \sig &
    \cmp{A^-}{P}}
\end{mathpar}
The left- and right-directed message-like atoms $\matom[<-]$ and $\matom[->]$ become the left- and right-directed messages $\msgL{\matom[<-]}$ and $\msgR{\matom[->]}$, respectively, in the \ac{SSOS}.
The process-like atom $\patom^+$ becomes $\exec{P}$, where $P$ is the process body of $\patom^+$'s definition in the choreography $\sig$.
Once again, the translation is defined in such a way that the behavior of contexts and their \ac{SSOS} translations match.

\subsection{Correctness of the translation}\label{sec:compile-correct}

As stressed in the preceding discussion, the principle that guided the translation's design was that the choreography's transitions should be matched by those of the process to which that choreography translates.
In other words, the translation, $\cmp{{-}}$, should be a strong bisimulation.

Unfortunately, that property does not quite hold: $\cmp{{-}}$ is not even a strong simulation.
Consider the choreography transition $\monad{A^+} \trans A^+$, for example.
For $\cmp{{-}}$ to be a strong (bi)simulation, there would have to be \iac{SSOS} transition $\exec{P} \trans \exec{P}$, where $\cmp{A^+}{P}$.
Such a transition simply does not exist in the \ac{SSOS} of our processes.

However, if we treat that choreography transition (and those obtained from it by the frame property) as silent, then it is true that $\cmp{{-}}$ is a \emph{weak simulation}: together $\monad{A^+} \strans A^+$ and $\cmp{A^+}{P}$ indeed (trivially) imply $\exec{P} \strans* \exec{P}$.
More generally:
% , $\cmp{{-}}$ is a weak simulation between the choreography and the process's \ac{SSOS}:
\begin{theorem}[Completeness]\mbox{}
  \begin{itemize}
  \item If $\octx \trans \octx'$ and $\cmp{\octx}{\lctx}$, then $\lctx \trans \lctx'$ for some $\lctx'$ such that $\cmp{\octx'}{\lctx'}$.
  \item If $\octx \strans \octx'$ and $\cmp{\octx}{\lctx}$, then $\lctx \strans* \lctx'$ for some $\lctx'$ such that $\cmp{\octx'}{\lctx'}$.
    % If $\octx_1 , \monad{A^+} , \octx_2 \strans \octx_1 , A^+ , \octx_2$ and $\cmp{\octx_1}{\lctx_1}$ and $\cmp{\octx_2}{\lctx_2}$, then $\cmp{\octx'}{\lctx}$ also.
  \end{itemize}
\end{theorem}
\begin{proof}
  By analyzing the structure of the given transition and translation.
  Notice that the given silent transition is necessarily $\omatch{\monad{A^+}} \strans \ofill{A^+}$ because no other transitions are defined to be silent.
\end{proof}

Neither is the inverse of $\cmp{{-}}$ a strong simulation.
Consider the \ac{SSOS} transition $\exec{(\call{\patom^+})} \trans \exec{P}$, where the body of the process definition of $\patom^+$ is $P$.
By examining the definition of $\cmp{{-}}$, we see that there would have to be a choreography transition $\patom^+ \trans \patom^+$ if the inverse of $\cmp{{-}}$ is to be a strong simulation.
Once again, such a transition simply does not exist.

However, if we treat that \ac{SSOS} transition (and those obtained from it by the frame property) as silent, then it is true that the inverse of $\cmp{{-}}$ is a \emph{weak simulation}: together $\exec{(\call{\patom^+})} \strans \exec{P}$ and $\cmp{\patom^+}{\exec{P}}$ indeed (trivially) imply $\patom^+ \strans* \patom^+$.
More generally: 
\begin{theorem}[Soundness]\mbox{}
  \begin{itemize}
  \item If $\lctx \trans \lctx'$ and $\cmp{\octx}{\lctx}$, then $\octx \trans \octx'$ for some $\octx'$ such that $\cmp{\octx'}{\lctx'}$.
  \item If $\lctx_1 , \exec{(\call{\patom^+})} , \lctx_2 \strans \lctx_1 , \exec{P} , \lctx_2$ and $\cmp{\octx_1}{\lctx_1}$ and $\cmp{\octx_2}{\lctx_2}$, then $\patom^+ \lrimp A^- \in \sig$ for some $A^-$ such that $\cmp{A^-}{P}$.
  \end{itemize}
\end{theorem}
\begin{proof}
  By analyzing the structure of the given transition and translation.
\end{proof}

Putting these two pieces together, $\cmp{{-}}$ is a weak bisimulation and $\cmp{{-}}$ is therefore correctly defined.


% As mentioned previously, guiding principle in the translation's design is that if the source specification $\octx$ translates to process chain $\lctx$, then each transition from $\octx$ should be matched by a transition from the process that results from translating the specification.
% As mentioned previously, guiding principle in the translation's design is that each transition from the source specification should be matched by a transition from the process that results from translating the specification.

% $\cmp{{-}}{{-}}$ is a weak bisimulation, when the transition $\omatch{\monad{A^+}} \trans \ofill{A^+}$ is a silent transition.  


% Just as the $\monad{-}$ modality is silent in the translation, we'll choose to classify the transition on ordered specifications from $\monad{A^+}$ to $A^+$ as silent: $\omatch{\monad{A^+}} \trans[\tau] \ofill{A^+}$.
% Then, the translation $\cmp{-}$ is a weak bisimulation: each transition is matched by a transition after translation, with the silent transitions disappearing.
% \begin{theorem}[Completeness]\mbox{}
%   \begin{itemize}
%   \item If $\octx \trans \octx'$ and $\cmp{\octx}{\lctx}$, then $\lctx \trans \lctx'$ for some $\lctx'$ such that $\cmp{\octx'}{\lctx'}$.
%   \item If $\octx \trans[\tau] \octx'$ and $\cmp{\octx}{\lctx}$, then $\cmp{\octx'}{\lctx}$ also.
%   \end{itemize}
% \end{theorem}
% \begin{proof}
%   By analyzing the definition of $\cmp{\octx}{\lctx}$. 
% \end{proof}

% \begin{theorem}[Soundness]\mbox{}
%   \begin{itemize}
%   \item If $\lctx \trans \lctx'$ and $\cmp{\octx}{\lctx}$, then $\octx \trans \octx'$ for some $\octx'$ such that $\cmp{\octx'}{\lctx'}$.
%   \item If $\lctx, \exec{(\call{\patom})} \trans \lctx, \exec{P}$ and $\cmp{\octx}{\lctx}$, then $\patom \lrimp A^- \in \sig$ for some $A^-$ such that $\cmp{A^-}{P}$.
%   \end{itemize}
% \end{theorem}


\subsection{Well-typed choreographies translate to well-typed processes}\label{sec:chor-types}

At this point, we can translate choreographies to syntactically well-formed processes.
However, not all choreographies translate to \emph{well-typed} processes.
For example, $(A^+_1 \fuse \matom[->]_1) \fuse (\matom[<-]_2 \fuse A^+_2)$ translates to the process $\spawn{(\selectR{\matom[->]_1 ; P_1}); (\selectL{\matom[<-]_2 ; P_2})}$, which is not typable in \acs{SISLL} because the messages have no matching recipients and therefore collide.

To identify a class of choreographies that enjoy the same session fidelity and, especially, deadlock freedom (\ie, progress) properties as well-typed processes, we need to introduce a typing discipline for choreographies, $\smash{\chseq}$, that is preserved by the translation.
The following theorem is our goal:
%
\begin{theorem*}[Translation preserves typing]\leavevmode
  \begin{itemize}
  \item If $\cmp{A^-}{P}$, then $\lctx \chseq A^- :: B$ if and only if $\lctx \vdash P :: B$.
  \item If $\cmp{A^+}{P}$, then $\lctx \chseq A^+ :: B$ if and only if $\lctx \vdash P :: B$.
  \end{itemize}
\end{theorem*}

Because $\cmp{{-}}$ describes a fairly tight correspondence between choreographies and processes, the rules for $\chseq$ are \enquote{just} the rules for typing processes ($\vdash$): simply replace the process terms with the corresponding ordered logic proposition.
For instance, $\matom[<-]_k \fuse A^+$ translates to $\selectL{\matom[<-]_k ; P}$ and so, from the $\lrule{\with}$ rule that types $\mathsf{selectL}$ processes, we obtain the rule for typing $\matom[<-]_k \fuse A^+$:
\begin{equation*}
  \lowered{
  \infer[\lrule{\with}]{\oseq{\hypof{\with*{\ell: A_\ell}[\ell \in L]} |- \procof{\selectL{\kay ; P}}{C}}}{
    \oseq{\hypof{A_{\kay}} |- \procof{P}{C}} &
    \text{($\kay \in L$)}}}
  %
  \quad\leftrightsquigarrow\quad
  %
  \lowered{
  \infer[\lrule{\with}]{\hypof{\with*{\ell: A_\ell}[\ell \in L]} \chseq \procof{\matom[<-]_{\kay} \fuse A^+}{C}}{
    \hypof{A_{\kay}} \chseq \procof{A^+}{C} &
    \text{($\kay \in L$)}}}
\end{equation*}
Notice how these new rules use two varieties of proposition in two different ways: polarized ordered propositions are choreographies; unpolarized (singleton) linear propositions serve as their types.
For this reason, the rules in isolation are admittedly a bit mind-bending, but they are in fact rather straightforward to derive if we keep the replacement pattern in mind.
As another example of the pattern, $\one$ translates to $\fwd$, the forwarding process, and so, from the $\id{A}$ rule that types $\fwd$ processes, we obtain the rule for typing $\one$ as a choreography:
\begin{equation*}
  \lowered{
    \infer[\id{A}]{\oseq{\hypof{A} |- \procof{\fwd}{A}}}{
      }}
  %
  \quad\leftrightsquigarrow\quad
  %
  \lowered{
  \infer[\id{A}]{A \chseq \procof{\one}{A}}{
    }}
\end{equation*}

% Following this pattern, most of the remaining rules for typing choreographies are straightforward to derive (though admittedly a bit mind-bending!).
Of the rules for typing choreographies, only two do not mimic process-typing rules. 
First is the rule for typing $\monad{A^+}$.
But, here again, the goal theorem shows the way;
the $\monad{{-}}$ modality is silent in the translation, so it should also be silent in the typing:
\begin{equation*}
  \infer{\lctx \chseq \procof{\monad{A^+}}{A}}{
    \lctx \chseq \procof{A^+}{A}}
\end{equation*}

Second is the rule for typing process-like atoms $\patom$.
Similarly to process variables, we assume that the programmer has specified the type of each process-like atom.
With this signature, we just check that each use of a process-like atom adheres to its specified type:
\begin{equation*}
  \infer{\lctx \chseq \patom^+ :: A}{
    \patom^+ : \{\lctx \chseq A\} \in \sig}  
\end{equation*}

The complete set of rules for typing choreographies is shown in \cref{fig:chor-typing}.
%
\begin{figure}
\begin{mathpar}
  \infer[\rrule{\with}]{\lctx \chseq \with*[\ell \in L][\parens]{\matom[<-]_\ell \rimp \monad{A^+_\ell}} :: \with*{\ell: A_\ell}[\ell \in L]}{
    \forall \ell \in L \mathpunct{:} \enskip \lctx \chseq A^+_\ell :: A_\ell}
  \and
  \infer[\lrule{\with}]{\with*{\ell: A_\ell}[\ell \in L] \chseq \matom[<-]_{\kay} \fuse A^+ :: C}{
    A_{\kay} \chseq A^+ :: C &
    \text{($\kay \in L$)}}
  \\
  \infer[\rrule{\ssor}]{\lctx \chseq A^+ \fuse \matom[->]_{\kay} :: \ssor*{\ell: A_\ell}[\ell \in L]}{
    \lctx \chseq A^+ :: A_{\kay} &
    \text{($\kay \in L$)}}
  \and
  \infer[\lrule{\ssor}]{\ssor*{\ell: A_\ell}[\ell \in L] \chseq \with*[\ell \in L][\parens]{\matom[->]_\ell \limp \monad{A^+_\ell}} :: C}{
    \forall \ell \in L\mathpunct{:}\enskip A_\ell \chseq A^+_\ell :: C}
  \\
  \infer{\lctx \chseq \monad{A^+} :: A}{
    \lctx \chseq A^+ :: A}
  \and
  \infer{\lctx \chseq \patom^+ :: A}{
    \patom^+ : \{\lctx \chseq A\} \in \sig}
  \\
  \infer[\cut{A}]{\lctx \chseq A^+_1 \fuse A^+_2 :: C}{
    \lctx \chseq A^+_1 :: A &
    A \chseq A^+_2 :: C}
  \and
  \infer[\id{A}]{A \chseq \one :: A}{
    }
\end{mathpar}
\caption{Choreography typing rules. The context $\lctx$ is either empty or a singleton.\label{fig:chor-typing}}
\end{figure}
%
It is easy to check that the goal indeed holds: the translation preserves typing.
\begin{theorem}[Translation preserves typing]\leavevmode
  \begin{itemize}
  \item If $\cmp{A^-}{P}$, then $\lctx \chseq A^- :: B$ if and only if $\lctx \vdash P :: B$.
  \item If $\cmp{A^+}{P}$, then $\lctx \chseq A^+ :: B$ if and only if $\lctx \vdash P :: B$.
  \end{itemize}
\end{theorem}
\begin{proof}
  By induction on the structure of the given typing derivation.
\end{proof}




Instead of using this theorem to justify the rules for typing choreographies, it's also possible to justify them from first principles if desired.
% It's also possible to justify the rules for typing choreographies from first principles. 
Consider the $\cut{A}$ rule, for example:
\begin{equation*}
  \infer[\cut{A}]{\lctx \chseq A^+_1 \fuse A^+_2 :: C}{
    \lctx \chseq A^+_1 :: A &
    A \chseq A^+_2 :: C}
\end{equation*}
This rule says that if the choreography $A^+_1$ has, from left to right, the interfaces $\lctx$ and $A$ (i.e.,~$\lctx \chseq A^+_1 :: A$) and the choreography $A^+_2$ has the interfaces $A$ and $C$ (i.e.,~$A \chseq A^+_2 :: C$), then their composition, $A^+_1 \fuse A^+_2$, has%
\begin{enumerate*}[label=\emph{\roman*)}, before={{: }}, itemjoin={{; }}, itemjoin*={{; and }}]
\item $\lctx$ as its left-hand interface, which is reasonable because the left-hand side of $A^+_1$ is exposed
\item $C$ as its right-hand interface, which is also reasonable because the right-hand side of $A^+_2$ is exposed
\end{enumerate*}.
The other rules can be given similar justifications.

% \end{document}
